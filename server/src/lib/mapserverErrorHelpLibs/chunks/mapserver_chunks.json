[
  {
    "id": 0,
    "text": "A MapServer mapfile is the core configuration file that tells MapServer where your data live and how to draw them. It must use the .map extension; otherwise MapServer can throw a “Filename validation failed” error. A mapfile always begins with a MAP object (the first token must be MAP). Inside MAP you define LAYER objects. Each LAYER combines geometry/attributes with styling through CLASS and STYLE blocks, which control colors, sizes, symbols, labels, and rendering behavior.",
    "keywords": [
      "mapfile",
      ".map extension",
      "Filename validation failed",
      "MAP object",
      "LAYER",
      "CLASS",
      "STYLE",
      "data location",
      "rendering configuration",
      "mapfile syntax"
    ]
  },
  {
    "id": 1,
    "text": "Public deployments should treat the MAP= request parameter as a security risk. Restrict which mapfiles MapServer is allowed to open by configuring environment variables such as MS_MAP_PATTERN or MS_MAP_NO_PATH, or by hiding/removing MAP= from public-facing URLs. This helps prevent attackers from loading arbitrary files or probing the filesystem. When debugging mapfile path errors, confirm that your allowed patterns, paths, and web server rewrites still let the intended .map file be found and that the mapfile extension and location meet your policy.",
    "keywords": [
      "MAP= parameter",
      "security hardening",
      "MS_MAP_PATTERN",
      "MS_MAP_NO_PATH",
      "mapfile access control",
      "public server",
      "path restriction",
      "environment variables",
      "filesystem probing",
      "rewrite rules"
    ]
  },
  {
    "id": 2,
    "text": "Cartographic symbols in MapServer are built from a few visual variables: form, size, pattern, color, and lightness; point/area symbols and text can also have an outline frame. MapServer applies these variables by combining a geometry type (point/line/polygon) with one or more STYLE definitions. Thinking in layers of graphical variables is useful when diagnosing “wrong looking” output: many visual issues come from where a variable is defined (SYMBOL vs STYLE) or from scale-dependent sizing.",
    "keywords": [
      "cartographic symbols",
      "visual variables",
      "form",
      "size",
      "pattern",
      "color",
      "lightness",
      "outline",
      "STYLE layering",
      "render diagnostics"
    ]
  },
  {
    "id": 3,
    "text": "Complex effects (e.g., highways with borders and centerlines) can be created by drawing the same data multiple times. The preferred approach is multiple STYLE blocks within one CLASS (overlay in draw order), rather than duplicating the geometry in separate LAYERs, which can hurt performance. Reordering STYLEs or LAYERs controls which symbols cover others (important for polygon outline vs fill clipping). Use LAYER/STYLE OPACITY to create transparency so lower symbols show through.",
    "keywords": [
      "multiple STYLE",
      "overlay rendering",
      "draw order",
      "performance",
      "duplicate layers",
      "polygon outline clipping",
      "STYLE order",
      "LAYER order",
      "OPACITY",
      "transparency"
    ]
  },
  {
    "id": 4,
    "text": "Symbol size can be treated as screen pixels (default) or real-world units that scale with map scale. Use LAYER SIZEUNITS (non-pixels) to specify symbol dimensions in units like meters. Alternatively, SYMBOLSCALEDENOM fixes the defined SIZE/WIDTH at a reference scale (1:SYMBOLSCALEDENOM) and scales proportionally at other scales. STYLE MAXSIZE and MINSIZE clamp the scaling range. When troubleshooting unexpected symbol growth/shrinkage, check SIZEUNITS, SYMBOLSCALEDENOM, and any MAXSIZE/MINSIZE constraints, then verify the map scale you are requesting.",
    "keywords": [
      "symbol scaling",
      "SIZEUNITS",
      "pixels",
      "real world units",
      "SYMBOLSCALEDENOM",
      "reference scale",
      "MAXSIZE",
      "MINSIZE",
      "scale-dependent styling",
      "troubleshooting size"
    ]
  },
  {
    "id": 5,
    "text": "MapServer organizes symbol rendering across several mapfile sections. LAYER TYPE defines the target geometry (POINT/LINE/POLYGON). Basic symbols are defined in SYMBOL blocks with TYPE, POINTS, IMAGE, FILLED, and ANCHORPOINT (and can be externalized into symbol files). STYLE blocks inside CLASS set COLOR, SIZE, WIDTH, and OUTLINECOLOR, and also control line/polygon patterns via PATTERN and GAP. A complex signature is usually multiple STYLE blocks in one CLASS, each referencing a SYMBOL.",
    "keywords": [
      "LAYER TYPE",
      "SYMBOL definition",
      "SYMBOL TYPE",
      "POINTS",
      "IMAGE",
      "FILLED",
      "ANCHORPOINT",
      "STYLE parameters",
      "PATTERN",
      "GAP",
      "composite symbols"
    ]
  },
  {
    "id": 6,
    "text": "A common pattern is building a composite point symbol using two STYLE blocks: a larger base symbol with outline plus a smaller symbol on top. For example, STYLE 1 references a “square” vector symbol, sets SIZE, COLOR, and OUTLINECOLOR; STYLE 2 references a “circle” ellipse symbol and sets a smaller SIZE and COLOR. Typical mapfile errors here include mismatched SYMBOL names (STYLE references a symbol that was never defined), missing END statements, or forgetting FILLED true for polygon-like vector symbols.",
    "keywords": [
      "composite point symbol",
      "square vector",
      "circle ellipse",
      "OUTLINECOLOR",
      "STYLE overlay",
      "SYMBOL name mismatch",
      "missing END",
      "FILLED true",
      "mapfile parsing error",
      "point styling"
    ]
  },
  {
    "id": 7,
    "text": "MapServer can output raster formats (PNG, JPEG, GIF) and vector formats (PDF, SVG). Raster outputs (except GIF) are typically anti-aliased, which can change the appearance of thin lines and small symbols. Output choices are controlled by MAP IMAGETYPE and OUTPUTFORMAT. If you see unexpected jagged edges or differences between PDF/SVG and PNG outputs, verify the renderer and output format settings, since symbol placement and anti-aliasing can affect perceived thickness and alignment.",
    "keywords": [
      "OUTPUTFORMAT",
      "IMAGETYPE",
      "PNG",
      "JPEG",
      "GIF",
      "PDF",
      "SVG",
      "anti-aliasing",
      "renderer differences",
      "output troubleshooting"
    ]
  },
  {
    "id": 8,
    "text": "Symbol dimensions depend not only on SIZEUNITS but also on MAP-level RESOLUTION and DEFRESOLUTION. DEFRESOLUTION defaults to 72 dpi; if RESOLUTION is raised (e.g., 144) then dimensions in the mapfile are multiplied by RESOLUTION/DEFRESOLUTION. This is a common cause of “everything doubled” in outputs. MapServer also allows decimal dimensions, which is useful for fine tuning. When debugging size inconsistencies across environments, compare RESOLUTION settings between servers and mapfiles.",
    "keywords": [
      "RESOLUTION",
      "DEFRESOLUTION",
      "dpi",
      "dimension scaling",
      "72 dpi default",
      "high resolution output",
      "decimal dimensions",
      "size inconsistency",
      "server differences",
      "symbol size debug"
    ]
  },
  {
    "id": 9,
    "text": "When symbols scale with map scale, rounding to pixels can shift components within a composite symbol, especially at small symbol sizes (large denominators). This can make symbols appear to “wiggle” or slightly change shape as scale changes. STYLE does not support MINSCALEDENOM/MAXSCALEDENOM for controlling display intervals, so scale-based switching must be done at the LAYER level (duplicate layers with different scale ranges). Always test symbols across your intended scale range to avoid surprises.",
    "keywords": [
      "rounding effects",
      "composite symbol drift",
      "scale changes",
      "pixel rounding",
      "MINSCALEDENOM",
      "MAXSCALEDENOM",
      "layer-level scale ranges",
      "duplicate layers",
      "symbol stability",
      "scale testing"
    ]
  },
  {
    "id": 10,
    "text": "Point symbols can be rotated with STYLE ANGLE. Since MapServer 6.2, the anchor/reference point for point symbols can be controlled with SYMBOL ANCHORPOINT (default 0.5 0.5, the symbol’s bounding-box center). For TYPE ellipse, POINTS define X and Y radii; equal values produce circles. For TYPE vector, POINTS define a shape in a local coordinate system (X right, Y down), and -99 -99 separates multiple elements. Negative coordinates are discouraged.",
    "keywords": [
      "point symbols",
      "ANGLE",
      "SYMBOL ANCHORPOINT",
      "TYPE ellipse",
      "TYPE vector",
      "POINTS",
      "-99 -99 separator",
      "local coordinates",
      "bounding box center",
      "symbol rotation"
    ]
  },
  {
    "id": 11,
    "text": "Vector symbols have practical limits and placement rules. By default the maximum number of POINTS is 100 (compile-time adjustable via MS_MAXVECTORPOINTS). The vector symbol bounding box treats (0,0) as the upper-left in symbol coordinates; this can be used for precise placement, though ANCHORPOINT is the recommended modern method. Style guidelines include avoiding downtilted lines in area symbols (aliasing) and not going below a useful minimum size. Errors often appear when a vector symbol exceeds the point limit or is malformed.",
    "keywords": [
      "vector symbol limits",
      "MS_MAXVECTORPOINTS",
      "100 points default",
      "bounding box",
      "symbol coordinate system",
      "aliasing",
      "minimum size",
      "ANCHORPOINT recommended",
      "malformed POINTS",
      "compile-time setting"
    ]
  },
  {
    "id": 12,
    "text": "Truetype symbols let you render a single font glyph as a symbol. In the SYMBOL block you set TYPE truetype, FONT (an alias from a font list), and CHARACTER (literal or ASCII). MAP FONTSET must be configured or fonts will fail to load. With the GD renderer (e.g., GIF) you can enable ANTIALIAS for smoother glyphs. Be aware that some symbol fonts number glyphs starting at 61440, so character codes may need an offset. Labels can also place text with LABEL POSITION codes.",
    "keywords": [
      "truetype symbol",
      "FONTSET",
      "FONT alias",
      "CHARACTER",
      "ASCII code",
      "ANTIALIAS",
      "GD renderer",
      "glyph numbering 61440",
      "LABEL",
      "POSITION"
    ]
  },
  {
    "id": 13,
    "text": "Pixmap symbols are small raster images referenced by IMAGE in a SYMBOL block (GIF/PNG supported). Unlike vector or truetype symbols, pixmap colors cannot be changed later in STYLE, so you must prepare the artwork in advance. You can mark a color index as transparent with TRANSPARENT to reveal underlying features. Watch color depth: using 24-bit PNG symbols in 8-bit mode can cause unexpected color banding. If scaling pixmaps, large SIZE values can expose pixelation; use STYLE MAXSIZE to cap growth when scaling is enabled.",
    "keywords": [
      "pixmap symbol",
      "IMAGE parameter",
      "GIF",
      "PNG",
      "TRANSPARENT",
      "color depth",
      "24-bit vs 8-bit",
      "cannot recolor",
      "pixelation",
      "MAXSIZE cap"
    ]
  },
  {
    "id": 14,
    "text": "Combining multiple point symbols in one CLASS works best when you manage SIZE carefully. In MapServer, STYLE SIZE refers to symbol height (Y extent), so two rectangles with the same SIZE can appear to have different areas depending on orientation. Raster rendering uses integer math, so overlaying symbols with mixed even/odd SIZE values can create centering irregularities. When troubleshooting “slightly off-center” composite symbols, align SIZE choices (avoid mixing even and odd) and verify that ANCHORPOINT is consistent across referenced symbols.",
    "keywords": [
      "combine symbols",
      "multiple STYLE",
      "SIZE is height",
      "integer rounding",
      "even/odd SIZE",
      "centering artifacts",
      "ANCHORPOINT consistency",
      "raster rendering",
      "composite alignment",
      "symbol overlay"
    ]
  },
  {
    "id": 15,
    "text": "Line styling starts with STYLE COLOR and WIDTH. If COLOR is omitted, the line may not render; if WIDTH is omitted, MapServer draws a thin 1-unit line. For more control, STYLE supports LINECAP (end caps), LINEJOIN (corner joins), and LINEJOINMAXSIZE (miter limit). These parameters matter most for thick lines, dashed patterns, and sharp corners. When a line looks “too long” at the ends or spikes at corners, LINECAP/LINEJOIN settings are usually the first place to check.",
    "keywords": [
      "line styling",
      "WIDTH",
      "COLOR",
      "default width",
      "LINECAP",
      "LINEJOIN",
      "LINEJOINMAXSIZE",
      "thick lines",
      "corner spikes",
      "render missing line"
    ]
  },
  {
    "id": 16,
    "text": "Overlaying multiple line styles is a standard technique for borders and centerlines. MapServer generally centers overlays on the baseline geometry, so a wide line under a narrower line creates a border of (wide−narrow)/2 units. If you want a centered 1-pixel line within a framed symbol, the widths may need adjustment (often prefer odd+even combinations like 11 and 17 rather than 10 and 16). A useful rule is to avoid mixing even and odd widths in the same composite line to reduce alignment artifacts.",
    "keywords": [
      "line overlay",
      "baseline geometry",
      "border thickness",
      "centerline",
      "width arithmetic",
      "even/odd widths",
      "alignment artifacts",
      "multi-style line",
      "cartographic framing",
      "style stacking"
    ]
  },
  {
    "id": 17,
    "text": "PATTERN creates dashed lines by listing alternating dash and gap lengths, repeated along the line. The PATTERN list is explicitly terminated with END. LINECAP influences dash ends: butt creates flat ends, round creates rounded ends, and square extends beyond the dash endpoint. To create dotted lines, use a dash length of 0 with LINECAP round. Common syntax errors include forgetting the PATTERN END token or placing PATTERN outside a STYLE block, which can trigger mapfile parsing failures.",
    "keywords": [
      "PATTERN",
      "dashed lines",
      "dash gap sequence",
      "PATTERN END",
      "LINECAP butt",
      "LINECAP round",
      "dots with 0 dash",
      "STYLE syntax",
      "parsing error",
      "line patterns"
    ]
  },
  {
    "id": 18,
    "text": "GAP places symbols repeatedly along a line (decorated lines), using a SYMBOL plus SIZE/ANGLE settings. Negative GAP values are used in examples to control placement behavior, and INITIALGAP (since 6.2) can offset where the first symbol is placed, working with both GAP and PATTERN for asymmetrical patterns. For asymmetric symbol placement relative to the line, prefer SYMBOL ANCHORPOINT (best method) over OFFSET tricks when possible. If symbols appear unevenly spaced, verify GAP units and any INITIALGAP setting.",
    "keywords": [
      "GAP",
      "decorated lines",
      "symbol placement",
      "INITIALGAP",
      "asymmetrical patterns",
      "negative GAP",
      "SYMBOL ANCHORPOINT",
      "SIZE",
      "ANGLE",
      "spacing issues"
    ]
  },
  {
    "id": 19,
    "text": "LINECAP and LINEJOIN strongly affect line aesthetics. MapServer’s default LINECAP is round, which slightly extends the line beyond its geometric endpoints—more noticeable as WIDTH increases. LINECAP butt stops exactly at the end; square extends beyond. For corners, LINEJOIN options include round (default), miter (sharp), bevel, and none (renders each segment with butt caps). If you see unexpected extensions, rounded ends, or corner “spurs,” check these settings, especially when PATTERN dashes are involved.",
    "keywords": [
      "LINECAP default round",
      "butt cap",
      "square cap",
      "LINEJOIN round",
      "miter join",
      "bevel join",
      "LINEJOIN none",
      "corner artifacts",
      "dash aesthetics",
      "line endpoint extension"
    ]
  },
  {
    "id": 20,
    "text": "LINEJOINMAXSIZE limits how far a miter join can extend at sharp corners. The maximum miter length is m_max = d * LINEJOINMAXSIZE, where d is the STYLE WIDTH. If the computed miter length exceeds m_max, it is clipped to m_max. This prevents exaggerated spikes in narrow angles when LINEJOIN miter is used. When sharp corners create extreme “needles,” reduce LINEJOINMAXSIZE or switch to LINEJOIN bevel/round to stabilize the appearance.",
    "keywords": [
      "LINEJOINMAXSIZE",
      "miter limit",
      "m_max formula",
      "WIDTH d",
      "miter spikes",
      "sharp corners",
      "bevel join",
      "round join",
      "corner clipping",
      "line aesthetics"
    ]
  },
  {
    "id": 21,
    "text": "STYLE OFFSET shifts symbols or lines. With normal X/Y values, the shift is absolute on the image (positive X right, positive Y down) and does not depend on the line direction. For shifting parallel lines relative to the original geometry, set OFFSET X -99: the X value becomes a perpendicular distance from the line, applied relative to the line direction (positive shifts to the right when looking along the line). Misusing -99 can cause confusing results, especially if you expected a simple screen-space translation.",
    "keywords": [
      "STYLE OFFSET",
      "screen-space shift",
      "perpendicular offset",
      "-99 offset mode",
      "parallel lines",
      "line direction",
      "positive X right",
      "positive Y down",
      "geometry-relative shift",
      "offset troubleshooting"
    ]
  },
  {
    "id": 22,
    "text": "Asymmetrical decorated lines can be built using point symbols placed off the baseline. You can do this by (a) OFFSET with Y=-99 so symbols follow an offset line, or (b) controlling placement using SYMBOL ANCHORPOINT (preferred). OFFSET-based methods may place symbols far from the intended line at sharp bends, because symbols are rendered along the offset geometry. If arrowheads, ticks, or tags drift around corners, try switching to ANCHORPOINT-based placement or simplifying the geometry to reduce sharp angles.",
    "keywords": [
      "asymmetrical line styling",
      "decorated lines",
      "point symbols on lines",
      "OFFSET Y=-99",
      "ANCHORPOINT preferred",
      "sharp bend artifacts",
      "arrowheads",
      "tags",
      "symbol drift",
      "geometry simplification"
    ]
  },
  {
    "id": 23,
    "text": "Polygon areas can be filled with solid color or tiled symbols. Tiled fills repeat the symbol’s bounding box across the polygon; STYLE SIZE scales the tile height and GAP increases spacing. Hatch fills use a SYMBOL of TYPE hatch: SIZE controls line spacing (center-to-center), WIDTH sets hatch stroke width, and ANGLE sets direction; since 6.2, PATTERN can make dashed hatches. Anti-aliasing (e.g., AGG renderer) can introduce edge halos around hatch tiles. If you see uneven hatch spacing, confirm SIZE units and renderer behavior.",
    "keywords": [
      "polygon fill",
      "tiled symbols",
      "symbol bounding box",
      "GAP spacing",
      "SIZE scaling",
      "TYPE hatch",
      "hatch ANGLE",
      "hatch WIDTH",
      "PATTERN dashed hatch",
      "anti-aliasing halos"
    ]
  },
  {
    "id": 24,
    "text": "Pixmap polygon fills can show grid-like artifacts when STYLE SIZE differs from the pixmap’s native height, and rotating pixmaps (ANGLE) for area fills is generally not recommended. Vector symbol fills rely on the vector symbol’s bounding box; thick vector line fills can be clipped if strokes extend outside that box. Polygon outlines are styled with OUTLINECOLOR, WIDTH, and optionally PATTERN (with LINECAP/LINEJOIN). Mapfile evolution matters for legacy configs: in 6.2 ANCHORPOINT and INITIALGAP were added; in 6.0 several styling parameters moved into STYLE; and current docs note open issues such as GAP vs PATTERN incompatibilities and lack of separate GAPX/GAPY for 2D fills. Also note CLASS BACKGROUNDCOLOR/COLOR were removed in 8.0 (use STYLEs), while CLASS DEBUG can help logging.",
    "keywords": [
      "pixmap polygon fill",
      "grid artifacts",
      "vector fill tiling",
      "bounding box clipping",
      "polygon outline",
      "OUTLINECOLOR",
      "dashed outline PATTERN",
      "MapServer 6.0 changes",
      "removed in 8.0",
      "CLASS DEBUG"
    ]
  },
  {
    "id": 25,
    "text": "The CLASS object defines how a subset of features in a LAYER will be styled and (optionally) labeled. A layer can include multiple CLASS blocks, evaluated in order, and a feature may match one or more classes depending on how you structure expressions and grouping. In MapServer 8.x many legacy per-class styling parameters were removed and must be expressed through one or more STYLE blocks inside the CLASS. When troubleshooting missing legend items, unexpected styling, or “no matching class” behavior, start by reviewing CLASS NAME/TITLE, the EXPRESSION logic, and whether a CLASSGROUP filter is active at the LAYER level.",
    "keywords": [
      "CLASS object",
      "feature classification",
      "multiple classes",
      "STYLE blocks",
      "MapServer 8.x",
      "legend missing",
      "CLASS NAME",
      "TITLE",
      "EXPRESSION logic",
      "CLASSGROUP",
      "troubleshooting"
    ]
  },
  {
    "id": 26,
    "text": "CLASS EXPRESSION decides which features belong to a class. MapServer supports several expression forms: simple string comparisons, regular expressions delimited with slashes, full logical expressions in parentheses using [ATTRIBUTE] references, and a string function such as length() for compact tests. The attribute used for simple comparisons and regex is typically set by LAYER CLASSITEM. Logical expressions can combine multiple attributes and operators (gt, lt, eq, and, or, ~, ~*), but are slower to evaluate. If no EXPRESSION is provided, MapServer treats all features as belonging to that class.",
    "keywords": [
      "CLASS EXPRESSION",
      "string comparison",
      "regular expression",
      "logical expression",
      "length()",
      "CLASSITEM",
      "attribute references",
      "performance",
      "operator ~",
      "operator ~*",
      "class matching"
    ]
  },
  {
    "id": 27,
    "text": "FALLBACK is a CLASS setting (added in MapServer 8.6) that turns the class into an “else” rule. A fallback class is applied only if none of the previously defined classes matched the feature, similar to an SLD ElseFilter. This is useful for default styling without writing a broad EXPRESSION like \"1\" that could unintentionally override other classes. When debugging class ordering problems, ensure the fallback class is last and confirm that earlier classes have valid expressions and required CLASSITEM settings.",
    "keywords": [
      "FALLBACK",
      "MapServer 8.6",
      "ElseFilter",
      "default styling",
      "class ordering",
      "last class",
      "SLD compatibility",
      "expression precedence",
      "debugging classes"
    ]
  },
  {
    "id": 28,
    "text": "CLASS GROUP works together with the LAYER-level CLASSGROUP parameter to selectively enable a subset of classes at render time. If a layer sets CLASSGROUP \"group1\", then only classes whose GROUP value equals \"group1\" are considered; other classes are ignored even if their EXPRESSION would match. GROUP names are simple strings and you can define multiple group families inside one layer. If features disappear after adding CLASSGROUP, check for typos or mismatched GROUP strings and verify that each intended CLASS includes a GROUP value.",
    "keywords": [
      "GROUP",
      "CLASSGROUP",
      "selective classes",
      "render-time filtering",
      "group mismatch",
      "features missing",
      "layer configuration",
      "class selection",
      "typo debugging"
    ]
  },
  {
    "id": 29,
    "text": "Classes can contribute to legends and labeling beyond basic styling. KEYIMAGE sets a specific legend icon for a CLASS, which can help when automatic legend rendering is misleading. A CLASS can include multiple LABEL blocks (since 6.2), and you can add a LEADER block (also since 6.2) to draw leader lines that connect labels to features. If label leaders or multiple labels fail to appear, check that LABEL/LEADER blocks are correctly nested inside the CLASS and that all objects are properly terminated with END.",
    "keywords": [
      "KEYIMAGE",
      "legend icon",
      "multiple LABEL blocks",
      "LEADER lines",
      "MapServer 6.2",
      "labeling",
      "nested blocks",
      "END statements",
      "label troubleshooting"
    ]
  },
  {
    "id": 30,
    "text": "Scale and visibility controls at the CLASS level help reduce clutter. Use MINSCALEDENOM and MAXSCALEDENOM to define the scale denominator interval where the class is drawn (e.g., 24000 for 1:24,000). MINFEATURESIZE sets a minimum feature size in pixels below which the feature is not rendered. These settings are a common source of “my data vanished” reports: confirm the current request scale, ensure denominators are not inverted, and verify MINFEATURESIZE is not filtering out small geometries such as short line segments or tiny polygons.",
    "keywords": [
      "MINSCALEDENOM",
      "MAXSCALEDENOM",
      "scale denominator",
      "MINFEATURESIZE",
      "clutter control",
      "data not drawn",
      "scale debugging",
      "visibility rules",
      "small features"
    ]
  },
  {
    "id": 31,
    "text": "MapServer 8.0 removed several legacy CLASS styling shortcuts such as BACKGROUNDCOLOR, COLOR, SIZE, MINSIZE, MAXSIZE, OUTLINECOLOR, and SYMBOL at the CLASS level; equivalent styling must be expressed using CLASS STYLE blocks. If you upgrade an older mapfile and see parse errors or missing symbols, migrate these parameters into STYLE definitions (COLOR, OUTLINECOLOR, WIDTH, SIZE, etc.). CLASS DEBUG remains available to increase verbosity (levels 0–5) and sends output to STDERR or to a logfile when WEB LOG is configured.",
    "keywords": [
      "removed in 8.0",
      "BACKGROUNDCOLOR",
      "CLASS COLOR",
      "CLASS SIZE",
      "OUTLINECOLOR",
      "SYMBOL removed",
      "STYLE migration",
      "upgrade issues",
      "CLASS DEBUG",
      "WEB LOG",
      "verbose output"
    ]
  },
  {
    "id": 32,
    "text": "CLASS TEXT controls the label string for features and overrides LAYER LABELITEM. TEXT can be a literal with [ATTRIBUTE] placeholders (e.g., '[FIRSTNAME] [LASTNAME]') or a full expression for more advanced formatting. Since 6.0 you can format numbers using tostring(), such as (\"Area is: \" + tostring([area],\"%.2f \")). TEMPLATE links a presentation template for query output, and METADATA stores arbitrary name/value pairs for clients. TITLE provides legend labeling, while NAME controls whether a class appears in legends.",
    "keywords": [
      "CLASS TEXT",
      "LABELITEM override",
      "attribute placeholders",
      "tostring formatting",
      "query TEMPLATE",
      "METADATA pairs",
      "TITLE",
      "NAME in legend",
      "label expressions",
      "number formatting"
    ]
  },
  {
    "id": 33,
    "text": "VALIDATION blocks in a CLASS define validation patterns for CGI parameter runtime substitutions and are preferred since MapServer 5.4. They let you whitelist allowed values or patterns for substituted parameters, reducing the risk of injection-style mistakes when users can influence query filters, class expressions, or templates. If runtime substitution behaves unexpectedly, check whether validation rules reject the provided value and confirm that the validation block is placed in the correct object scope (often LAYER or CLASS). Combine VALIDATION with server-side restrictions on mapfile access for stronger hardening.",
    "keywords": [
      "VALIDATION block",
      "runtime substitution",
      "CGI parameters",
      "MapServer 5.4",
      "whitelisting",
      "security hardening",
      "pattern validation",
      "injection prevention",
      "scope errors"
    ]
  },
  {
    "id": 34,
    "text": "The CLUSTER object (available since MapServer 6.0 via RFC 69) aggregates nearby point features into a single rendered “cluster” feature based on screen proximity. Only TYPE POINT layers support clustering. Clustering is useful for dense datasets (e.g., station locations) where drawing every point would overlap. Typically you label clusters with the number of contained points and style single features differently. If clustering appears to do nothing, confirm the layer TYPE is POINT, that a CLUSTER block exists, and that MAXDISTANCE is large enough for your map scale and resolution.",
    "keywords": [
      "CLUSTER",
      "RFC 69",
      "MapServer 6.0",
      "point aggregation",
      "TYPE POINT",
      "dense points",
      "MAXDISTANCE",
      "cluster label",
      "overlap reduction",
      "clustering debug"
    ]
  },
  {
    "id": 35,
    "text": "CLUSTER parameters define how neighbors are negotiated. MAXDISTANCE sets the search distance in pixels (must be >0), and REGION chooses the search shape (rectangle or ellipse). BUFFER extends the map extent in pixels so points just outside the view can still contribute to clusters. GROUP is an expression that partitions features into separate cluster groups; its value is available as Cluster_Group. FILTER is evaluated after clustering and can use Cluster_FeatureCount to keep or reject clusters (e.g., hide clusters with too few or too many neighbors).",
    "keywords": [
      "MAXDISTANCE",
      "REGION ellipse",
      "REGION rectangle",
      "BUFFER",
      "GROUP expression",
      "Cluster_Group",
      "FILTER post-cluster",
      "Cluster_FeatureCount",
      "neighbor negotiation",
      "pixel distance"
    ]
  },
  {
    "id": 36,
    "text": "Cluster layers support PROCESSING options that affect both rendering and queries. CLUSTER_GET_ALL_SHAPES=ON returns all original shapes inside a cluster instead of a single representative, which is especially important for GetFeatureInfo. CLUSTER_KEEP_LOCATIONS=ON preserves locations so all points in a cluster can be shown. CLUSTER_ALGORITHM=SIMPLE (since 6.2) trades some accuracy for better performance. CLUSTER_USE_MAP_UNITS=ON makes clustering scale-independent by interpreting distances in map units. ITEMS lets you expose selected source attributes during query operations.",
    "keywords": [
      "PROCESSING",
      "CLUSTER_GET_ALL_SHAPES",
      "CLUSTER_KEEP_LOCATIONS",
      "CLUSTER_ALGORITHM=SIMPLE",
      "MapServer 6.2",
      "CLUSTER_USE_MAP_UNITS",
      "scale independent",
      "ITEMS option",
      "GetFeatureInfo"
    ]
  },
  {
    "id": 37,
    "text": "A clustered layer exposes aggregated attributes that can be used in expressions and labels. Cluster_FeatureCount reports the number of features in the cluster, and Cluster_Group reports the evaluated group key. In MapServer 6.x these attribute names used a colon (e.g., Cluster:FeatureCount); MapServer 7 switched to underscores. For source-layer attributes you can specify aggregation using a prefix such as [Max:itemname], [Min:itemname], [Sum:itemname], or [Count:itemname]. Without an aggregate function, attribute values can be non-deterministic when clusters contain mixed values.",
    "keywords": [
      "Cluster_FeatureCount",
      "Cluster_Group",
      "MapServer 6.x colon",
      "MapServer 7 underscore",
      "aggregate functions",
      "Max:",
      "Min:",
      "Sum:",
      "Count:",
      "non-deterministic attributes"
    ]
  },
  {
    "id": 38,
    "text": "To support WMS GetFeatureInfo on all features inside a cluster, configure metadata and processing carefully. Set layer metadata such as \"wms_include_items\" (often \"all\") as you would for non-cluster layers, then enable PROCESSING \"CLUSTER_GET_ALL_SHAPES=ON\" so queries return every feature in the cluster. Use PROCESSING \"ITEMS=name,description\" (or a similar comma list) to control which attributes are exposed. If GetFeatureInfo only returns a single point or missing attributes, it usually means CLUSTER_GET_ALL_SHAPES is off, ITEMS is not configured, or the request is not including those items.",
    "keywords": [
      "WMS GetFeatureInfo",
      "wms_include_items",
      "CLUSTER_GET_ALL_SHAPES=ON",
      "ITEMS processing",
      "attribute exposure",
      "query results",
      "cluster queries",
      "metadata",
      "debugging GetFeatureInfo"
    ]
  },
  {
    "id": 39,
    "text": "A typical clustering mapfile pattern uses two classes: one for clusters and one for single features. For example, set LABELITEM and CLASSITEM to Cluster_FeatureCount, then define CLASS 1 with an expression like (\"[Cluster_FeatureCount]\" != \"1\") to style and label clusters (often a circle with a count label). Define CLASS 2 with a broad expression (\"1\") to style single stations and use TEXT \"[Name]\" to label them when only one LABELITEM can be set. Query behavior can be tuned with TOLERANCE, UNITS, and TEMPLATE/HEADER/FOOTER paths.",
    "keywords": [
      "cluster classes",
      "LABELITEM",
      "CLASSITEM",
      "Cluster_FeatureCount",
      "expression != 1",
      "single feature class",
      "TEXT [Name]",
      "TOLERANCE",
      "UNITS PIXELS",
      "query templates"
    ]
  },
  {
    "id": 40,
    "text": "The COMPOSITE block (available since MapServer 7.0, RFC 113) enables blending effects by rendering a layer into a temporary image and compositing it onto the main map. This is valuable for cartographic effects like blending raster hillshades over vector layers or simulating overprinting. The default compositing operator is \"src-over\" (normal draw order), but many other blend modes are available. Advanced blending (anything except src-over) can affect performance, so use it selectively and test rendering speed on realistic datasets and output sizes.",
    "keywords": [
      "COMPOSITE",
      "MapServer 7.0",
      "RFC 113",
      "blend modes",
      "hillshade overlay",
      "overprinting",
      "temporary image",
      "src-over",
      "performance impact",
      "cartographic effects"
    ]
  },
  {
    "id": 41,
    "text": "COMPFILTER (added in 7.2) applies image filters before compositing. Supported filters include blur(integer), translate(x,y), grayscale(), blacken(), and whiten(). You can chain multiple filters to build combined effects, such as translating a blurred copy to create a soft shadow behind features. If a filter has no visible effect, confirm it is inside the COMPOSITE block, check integer arguments, and remember that filters operate on the layer’s temporary image, so their impact depends on the layer’s opacity and the chosen compositing operator.",
    "keywords": [
      "COMPFILTER",
      "MapServer 7.2",
      "blur",
      "translate",
      "grayscale",
      "blacken",
      "whiten",
      "soft shadow",
      "filter chain",
      "composite troubleshooting"
    ]
  },
  {
    "id": 42,
    "text": "COMPOP selects the compositing operator used to blend the COMPOSITE image onto the destination. Operators include artistic modes like darken, lighten, multiply, screen, overlay, and difference, plus masking-style operators such as dst-in, dst-out, src-in, and src-atop. The default is src-over. Some operators are marked as limited: those with a star are supported only with AGG backends when pixman support is not enabled, and they fall back to src-over otherwise. When a blend mode seems ignored, verify your renderer/backend and pixman configuration.",
    "keywords": [
      "COMPOP",
      "compositing operator",
      "multiply",
      "screen",
      "overlay",
      "darken",
      "dst-in",
      "dst-out",
      "AGG backend",
      "pixman fallback",
      "blend ignored"
    ]
  },
  {
    "id": 43,
    "text": "COMPOSITE OPACITY sets transparency for all classed pixels of a layer, using values from 0 (fully transparent) to 100 (fully opaque). Specifying only OPACITY provides simple transparency and matches the effect of the legacy LAYER OPACITY parameter. You can combine OPACITY with COMPOP (e.g., darken) for stronger visual effects. If opacity behaves differently than expected, check whether multiple styles or multiple classes are contributing pixels, and confirm that output format and renderer (PNG vs PDF/SVG) are not changing how alpha blending is handled.",
    "keywords": [
      "OPACITY",
      "0 to 100",
      "legacy LAYER OPACITY",
      "transparency",
      "alpha blending",
      "COMPOP darken",
      "multiple classes",
      "renderer differences",
      "output format"
    ]
  },
  {
    "id": 44,
    "text": "As of MapServer 8.0 a global configuration file is required (RFC 135) to provide site-level security and settings shared by all mapfiles. The config file path is set by the MAPSERVER_CONFIG_FILE environment variable, and some installations define a default location at compile time. If MapServer cannot find or read the file, it returns errors such as msLoadConfig(): Unable to access file. For command-line testing, utilities like map2img include a -conf switch to specify the configuration file explicitly.",
    "keywords": [
      "MapServer 8.0",
      "global config file",
      "RFC 135",
      "MAPSERVER_CONFIG_FILE",
      "msLoadConfig error",
      "site-level config",
      "map2img -conf",
      "security settings",
      "deployment"
    ]
  },
  {
    "id": 45,
    "text": "The CONFIG file’s ENV section stores environment variables as name/value pairs, including MS_MAP_PATTERN used to restrict which mapfiles can be loaded by path. In MapServer 8.0+ you may omit MS_MAP_PATTERN if you use MAPS aliases or if the web server already sets MS_MAP_PATTERN (MapServer will fall back to existing MS* environment variables). MS_MAP_NO_PATH can disable path-based map= parameters so only aliases are accepted. When mapfile requests fail after hardening, check whether the requested path matches MS_MAP_PATTERN or whether MS_MAP_NO_PATH forces an alias-only workflow.",
    "keywords": [
      "CONFIG ENV",
      "MS_MAP_PATTERN",
      "limit mapfile access",
      "MS_MAP_NO_PATH",
      "alias-only",
      "environment fallback",
      "map= parameter",
      "hardening",
      "request failures"
    ]
  },
  {
    "id": 46,
    "text": "The CONFIG file’s MAPS section maps friendly aliases to full mapfile paths. Aliases are case-insensitive, so keys like \"ITASCA\" and \"Itasca\" behave the same. Using aliases reduces exposure of server paths and can simplify URLs, including OGC API: Features routes (e.g., /mapserver/itasca/ogcapi/collections). Since MapServer 8.2, all request types can use MAPS keys directly in URLs, not only OGC API endpoints. If MS_MAP_NO_PATH is enabled, these aliases become the only valid values for the map= CGI parameter.",
    "keywords": [
      "CONFIG MAPS",
      "map aliases",
      "case-insensitive keys",
      "OGC API Features",
      "URL simplification",
      "MapServer 8.2",
      "map= CGI",
      "path hiding",
      "MS_MAP_NO_PATH"
    ]
  },
  {
    "id": 47,
    "text": "The CONFIG file’s PLUGINS section is a registry that maps short plugin keys to specific library paths (for example, an MS SQL plugin DLL). This helps prevent unsafe or unexpected libraries from being loaded by a mapfile, because only registered plugin paths can be referenced. In multi-tenant deployments or shared servers, PLUGINS is an important security control: it centralizes which optional drivers are permitted. If a plugin-backed connection fails after moving to a config file, verify that the plugin key exists in PLUGINS and the library path is accessible to the MapServer process.",
    "keywords": [
      "CONFIG PLUGINS",
      "plugin registry",
      "library path",
      "MS SQL plugin",
      "unsafe library prevention",
      "driver allowlist",
      "multi-tenant security",
      "plugin load failure",
      "filesystem permissions"
    ]
  },
  {
    "id": 48,
    "text": "Displaying international characters in MapServer requires appropriate encoding support. MapServer must be compiled with libiconv, and in MapServer 7.0+ the ENCODING parameter is set at the LAYER level (reflecting that encoding affects the whole dataset, not just labels). MapServer converts strings internally to UTF-8 so outputs like GetCapabilities, GetFeature, and query responses are returned as UTF-8. A practical workflow is: run mapserv -v to confirm SUPPORTS=ICONV, confirm your file encoding is supported (iconv -l can list encodings), and then set LAYER ENCODING (e.g., \"SHIFT_JIS\").",
    "keywords": [
      "international characters",
      "libiconv",
      "SUPPORTS=ICONV",
      "LAYER ENCODING",
      "MapServer 7.0",
      "UTF-8 conversion",
      "GetCapabilities UTF-8",
      "iconv -l",
      "SHIFT_JIS"
    ]
  },
  {
    "id": 49,
    "text": "For MapServer versions earlier than 7.0, encoding was configured at the LABEL level using LABEL ENCODING, which is now deprecated (though compatibility logic remains). PHP MapScript exposes this through the label object so scripts can read or set encoding (e.g., set(\"encoding\",\"UTF-8\")). Always save the mapfile itself in UTF-8 in your editor to avoid hidden character issues, and test rendering with map2img when debugging label problems. The MapServer 7.6.0 release also fixed handling of special characters (like umlauts) in filenames and paths referenced in mapfiles.",
    "keywords": [
      "LABEL ENCODING",
      "pre-7.0 behavior",
      "deprecated encoding",
      "PHP MapScript",
      "label object",
      "map2img testing",
      "mapfile UTF-8",
      "MapServer 7.6 fix",
      "special characters in paths"
    ]
  },
  {
    "id": 50,
    "text": "MapServer expressions are used to filter and classify data and to build label text. Since 6.0 expressions can appear in LAYER FILTER, CLASS EXPRESSION, CLASS TEXT, and STYLE GEOMTRANSFORM. Strings can be quoted with single or double quotes, and escaping rules depend on version: prior to 5.0 quote escaping was not supported, while 5.0 introduced C-like escapes (e.g., \\\"), and 6.0 relaxed escaping requirements by allowing mixed quote types. When expression parsing fails, the culprit is often mismatched quotes or missing parentheses around logical expressions.",
    "keywords": [
      "expressions",
      "LAYER FILTER",
      "CLASS EXPRESSION",
      "CLASS TEXT",
      "STYLE GEOMTRANSFORM",
      "string quoting",
      "escape sequences",
      "version differences",
      "parse errors",
      "parentheses"
    ]
  },
  {
    "id": 51,
    "text": "Attributes are referenced by enclosing the name in square brackets, like [ATTRIBUTENAME]; attribute names are case sensitive and must match the datasource fields. In label strings you can embed attributes inside quoted text (e.g., 'The [BUILDING_NAME] building'). Raster layers expose special pseudo-attributes for classification such as [PIXEL] and per-channel values [RED], [GREEN], and [BLUE]. If your expression always evaluates false, confirm the attribute name’s case, verify the item exists in the layer, and ensure you are not unintentionally treating a numeric attribute as a quoted string.",
    "keywords": [
      "attribute references",
      "[ATTRIBUTENAME]",
      "case sensitive",
      "label concatenation",
      "raster pseudo-attributes",
      "PIXEL",
      "RED GREEN BLUE",
      "expression always false",
      "type mismatch",
      "datasource fields"
    ]
  },
  {
    "id": 52,
    "text": "Simple string comparisons are the fastest expression type. For LAYER filtering, set FILTERITEM to the attribute name and FILTER to the comparison value; similarly, classification uses LAYER CLASSITEM with CLASS EXPRESSION. Regular expression comparisons use slash-delimited patterns like /hotel/ and are case sensitive by default; MapServer also supports ~ (case sensitive) and ~* (case insensitive) operators in logical expressions. A practical rule is to avoid FILTER or EXPRESSION values that begin with '/' or '(' unless you intend regex or logical syntax. Frequent segmentation faults with regex can indicate conflicting regex libraries in a mixed build (e.g., Apache/PHP).",
    "keywords": [
      "FILTERITEM",
      "FILTER",
      "CLASSITEM",
      "fast string comparison",
      "regex /pattern/",
      "case sensitive regex",
      "~ operator",
      "~* operator",
      "leading / or ( rule",
      "regex segfault",
      "library conflict"
    ]
  },
  {
    "id": 53,
    "text": "List expressions (added in 6.4, RFC 95) provide a performant way to match a string attribute against multiple tokens by writing {value1,value2} without quotes or extra spaces. They behave like a regex alternation or an IN test but are faster. For more complex logic, MapServer expressions use parentheses and typed literals: strings in quotes, numbers unquoted, and date-time values in backquotes. Logical operators include AND/OR/NOT (or &&/||/!), and comparisons support eq/ne/lt/gt plus an IN operator for token lists. Values equal to zero are treated as false in numeric contexts.",
    "keywords": [
      "list expressions",
      "MapServer 6.4",
      "RFC 95",
      "{value1,value2}",
      "IN operator",
      "typed literals",
      "backquoted datetime",
      "AND OR NOT",
      "&& || !",
      "numeric truthiness"
    ]
  },
  {
    "id": 54,
    "text": "Spatial and temporal expressions extend MapServer’s filtering power when built with GEOS. Spatial predicates include intersects, disjoint, touches, overlaps, crosses, within, contains, dwithin, and beyond. Spatial functions such as area(shape) return numbers, while fromtext(WKT), buffer(shape,distance), and difference(a,b) return shapes. Temporal expressions parse many ISO-like formats (YYYY-MM-DD, YYYY-MM-DDThh:mm:ssZ, etc.) and compare them with eq/ne/lt/gt operators. Common utility functions include tostring(number,format), commify(string), upper/lower/initcap, and round() (with an integer-only variant added in 8.0).",
    "keywords": [
      "GEOS",
      "spatial predicates",
      "intersects",
      "within contains",
      "fromtext WKT",
      "buffer()",
      "difference()",
      "temporal formats",
      "ISO 8601",
      "tostring",
      "commify",
      "round 8.0"
    ]
  },
  {
    "id": 55,
    "text": "Inline FEATURE definitions let you embed geometries directly in a mapfile layer. Geometry can be defined with POINTS as a sequence of x/y pairs terminated by END; polygon and polyline POINTS must start and end with the same coordinate to close the feature. Multipart features are created by adding multiple POINTS blocks inside one FEATURE. You can attach attribute values with ITEMS (a semicolon-separated list) and provide labeling text with TEXT. Alternatively, WKT can define geometry in OpenGIS Well Known Text, but requires OGR or GEOS support. If a layer also specifies another CONNECTIONTYPE, inline features take precedence and the external datasource is ignored.",
    "keywords": [
      "FEATURE inline",
      "POINTS END",
      "close polygon",
      "multipart feature",
      "ITEMS semicolon list",
      "TEXT label",
      "WKT geometry",
      "OGR support",
      "GEOS support",
      "inline precedence",
      "CONNECTIONTYPE ignored"
    ]
  },
  {
    "id": 56,
    "text": "FONTSET is a MAP-level parameter that points to a fontset file listing available TrueType fonts. Each line in the fontset file contains an alias and a font filename/path separated by whitespace; the alias is what you reference in LABEL or SYMBOL blocks. If the font path is not absolute, it is interpreted relative to the fontset file’s location. Aliases are case sensitive, so inconsistent capitalization can cause “font not found” behavior. When moving mapfiles between servers, keep relative FONTSET paths stable or switch to absolute paths, and ensure the MapServer process can read the .ttf files.",
    "keywords": [
      "FONTSET",
      "MAP parameter",
      "font alias",
      "TrueType .ttf",
      "fontset file format",
      "relative paths",
      "absolute paths",
      "case sensitive alias",
      "font not found",
      "deployment migration"
    ]
  },
  {
    "id": 57,
    "text": "GEOMTRANSFORM (Geometry Transformations) modifies feature geometry during styling. In CLASS STYLE contexts you can apply transforms such as bbox (bounding box), centroid, start/end (line endpoints), or vertices. For label placement, LABEL STYLE supports labelpnt and labelpoly transforms to derive point/polygon label geometries. GEOMTRANSFORM is frequently used to create derived markers (e.g., centroids for polygons) without duplicating layers. If transforms produce unexpected positions, confirm the transform is placed in the correct object (STYLE vs LABEL STYLE), and remember that transformations operate on the feature geometry after projection and clipping.",
    "keywords": [
      "GEOMTRANSFORM",
      "bbox",
      "centroid",
      "start end",
      "vertices",
      "labelpnt",
      "labelpoly",
      "derived geometry",
      "STYLE context",
      "label placement",
      "transform debugging"
    ]
  },
  {
    "id": 58,
    "text": "GEOMTRANSFORM can be applied at two levels with different coordinate spaces. At the LAYER level (since 6.4) transformations operate on the original vector geometry in map units (“real world” coordinates). At the CLASS STYLE level (since 6.0) transformations operate in pixel coordinates after projection/clipping. If you want pixel-like tolerances at the LAYER level, define LAYER UNITS and use the built-in [map_cellsize] variable to convert pixels to map units, e.g. GEOMTRANSFORM (simplify([shape], [map_cellsize]*10)). When results look wrong, first verify which level you used and whether the tolerances are in pixels or map units.",
    "keywords": [
      "GEOMTRANSFORM",
      "LAYER level",
      "STYLE level",
      "pixel coordinates",
      "map units",
      "map_cellsize",
      "UNITS",
      "tolerance conversion",
      "projection/clipping",
      "debugging transforms"
    ]
  },
  {
    "id": 59,
    "text": "The simple GEOMTRANSFORM \"bbox\" (CLASS STYLE only) replaces the feature geometry with its bounding box. A common pattern is to draw the original line/polygon with one STYLE, then add a second STYLE using GEOMTRANSFORM \"bbox\" to render a dashed outline around the bounds (e.g., OUTLINECOLOR plus PATTERN). If bbox appears to do nothing, check that GEOMTRANSFORM is inside a STYLE block within a CLASS (not at LAYER level for this simple transform) and that PATTERN is properly terminated with END. Parsing errors often come from missing END tokens inside the STYLE/PATTERN blocks.",
    "keywords": [
      "bbox",
      "bounding box",
      "CLASS STYLE only",
      "STYLE block",
      "OUTLINECOLOR",
      "PATTERN END",
      "dashed outline",
      "mapfile nesting",
      "missing END",
      "geomtransform troubleshooting"
    ]
  },
  {
    "id": 60,
    "text": "GEOMTRANSFORM \"centroid\" (CLASS STYLE only) converts polygons (and other geometries) to a single point at the centroid, which is useful for placing markers without duplicating layers. Typically you pair it with a point SYMBOL (e.g., an ellipse \"circlef\" with FILLED true) and a small SIZE. If the symbol doesn’t render, verify the SYMBOL name matches, the symbol is defined in the SYMBOLSET, and that the layer TYPE and CLASS context allow point rendering. When centroids appear shifted, remember STYLE-level transforms use pixel coordinates and are affected by reprojection and clipping.",
    "keywords": [
      "centroid",
      "CLASS STYLE",
      "polygon marker",
      "SYMBOL circlef",
      "FILLED true",
      "SIZE",
      "symbol not found",
      "layer TYPE",
      "pixel-space transform",
      "centroid debugging"
    ]
  },
  {
    "id": 61,
    "text": "GEOMTRANSFORM \"start\" and \"end\" (CLASS STYLE only) extract the first or last vertex of a line as a point, and MapServer exposes the line direction at those endpoints for rendering effects. Because END terminates mapfile objects, the \"end\" transform must be quoted. A typical style stack draws the line, then adds arrowhead symbols at the start and end with ANGLE auto and different ANCHORPOINT values (e.g., 0 0.5 for start, 1 0.5 for end). If arrows point the wrong way, confirm ANGLE auto is set and check that the symbol’s coordinate system and ANCHORPOINT are correct.",
    "keywords": [
      "start",
      "end",
      "quoted end",
      "line endpoints",
      "ANGLE auto",
      "arrowhead symbol",
      "ANCHORPOINT",
      "direction rendering",
      "line styling",
      "endpoint troubleshooting"
    ]
  },
  {
    "id": 62,
    "text": "GEOMTRANSFORM \"vertices\" (CLASS STYLE only) outputs the set of vertices of a line and includes direction information, enabling repeated symbols along the line’s vertex locations. A common example uses a thin vector symbol (like a short vertical tick) with ANGLE AUTO so each tick rotates with the line direction, while another STYLE draws the base line. If you get unexpected symbol rotations, verify you used ANGLE AUTO (case-insensitive) and that the symbol itself is oriented correctly (vector POINTS typically assume X right, Y down). If nothing draws, ensure the transform is in a STYLE inside CLASS and the layer TYPE is LINE.",
    "keywords": [
      "vertices",
      "CLASS STYLE only",
      "vertex ticks",
      "ANGLE AUTO",
      "vector symbol",
      "direction info",
      "LINE layer",
      "symbol rotation",
      "STYLE stacking",
      "debugging vertices"
    ]
  },
  {
    "id": 63,
    "text": "For label styling, GEOMTRANSFORM \"labelpnt\" and \"labelpoly\" are available only inside LABEL STYLE blocks. labelpnt returns the geographic attachment point of the label, which is the text center only when POSITION is CC. labelpoly returns a polygon covering the rendered label with 1-pixel padding, making it ideal for background rectangles, outlines, or shadows using COLOR/OUTLINECOLOR and OFFSET. Note that the result of labelpnt is affected by LAYER LABELCACHE: when LABELCACHE is ON (default), adding a non-zero sized symbol with labelpnt can shift the label. If label backgrounds are missing, check nesting (CLASS → LABEL → STYLE) and GEOMTRANSFORM scope.",
    "keywords": [
      "labelpnt",
      "labelpoly",
      "LABEL STYLE",
      "label background",
      "shadow OFFSET",
      "OUTLINECOLOR",
      "LABELCACHE",
      "POSITION CC",
      "nesting errors",
      "label styling debug"
    ]
  },
  {
    "id": 64,
    "text": "Advanced geometry transformations are written as expressions and can be chained by replacing the [shape] placeholder with another transformation expression. For example, GEOMTRANSFORM (simplify(buffer([shape], 20),10)) buffers the geometry first, then simplifies the buffered result. You can also combine a LAYER-level expression transform with a CLASS STYLE simple transform (e.g., LAYER GEOMTRANSFORM (simplify(buffer([shape], 10),5)) then a STYLE GEOMTRANSFORM \"vertices\" to draw vertex ticks on the transformed geometry). When output looks inconsistent, confirm where each transform runs (map units at LAYER vs pixels in STYLE) and ensure parentheses and quoting are balanced—syntax mistakes in nested expressions are a frequent source of parse errors.",
    "keywords": [
      "chaining expressions",
      "replace [shape]",
      "simplify(buffer())",
      "nested parentheses",
      "LAYER vs STYLE",
      "map units vs pixels",
      "parse errors",
      "expression geomtransform",
      "combining transforms",
      "debugging syntax"
    ]
  },
  {
    "id": 65,
    "text": "GEOMTRANSFORM buffer([shape], buffersize) returns a polygon buffer around the original geometry and can be used at the LAYER level or in CLASS STYLE. Negative buffers (setbacks) are not supported, and documentation notes buffer may not work for point geometries. A common cartographic use is multi-STYLE buffering (e.g., 20/10/5) to create concentric outlines and fills. If buffering fails, check you have GEOS support compiled in, verify buffersize is positive, and confirm you are not applying it to points. Also watch for performance issues on complex geometries—buffering is computationally heavier than simple styling.",
    "keywords": [
      "buffer",
      "buffer([shape],size)",
      "polygon output",
      "no negative setback",
      "GEOS required",
      "points limitation",
      "concentric buffers",
      "LAYER or STYLE",
      "performance",
      "buffer troubleshooting"
    ]
  },
  {
    "id": 66,
    "text": "MapServer 8.0 added centerline([shape]) to generate a centered line inside a polygon (useful for labeling lakes or provinces). It uses a Voronoi diagram produced by GEOS and then simplifies the result; it requires GEOS >= 3.5 and only works on polygon shapes. A typical workflow is LAYER TYPE LINE with GEOMTRANSFORM (centerline(densify([shape], 0.1))) to make the line follow the polygon more closely, then a LABEL with ANGLE FOLLOW to place text along the generated line. If centerlines are missing, confirm your input is polygon geometry and your GEOS version meets the requirement.",
    "keywords": [
      "centerline()",
      "MapServer 8.0",
      "GEOS >= 3.5",
      "polygon only",
      "Voronoi diagram",
      "labeling lakes",
      "ANGLE FOLLOW",
      "densify()",
      "generated line",
      "centerline troubleshooting"
    ]
  },
  {
    "id": 67,
    "text": "The densify([shape], tolerance) transform (added in 8.0) inserts additional vertices into the input geometry and requires a positive tolerance value. It is often paired with centerline() so the generated labeling line contains enough vertices to resemble the original polygon boundary, improving ANGLE FOLLOW labeling. If densify throws errors or has no effect, check the tolerance is greater than zero and remember that extremely small tolerances can create very dense output geometries that slow rendering. When performance drops, try a larger tolerance or apply simplify/simplifypt after densify to reduce vertex count.",
    "keywords": [
      "densify()",
      "added in 8.0",
      "positive tolerance",
      "add vertices",
      "centerline combination",
      "ANGLE FOLLOW labels",
      "dense geometry",
      "render slowdown",
      "simplifypt",
      "tolerance tuning"
    ]
  },
  {
    "id": 68,
    "text": "GEOMTRANSFORM generalize([shape], tolerance) simplifies geometry using an approach comparable to FME’s ThinNoPoint algorithm and depends on GEOS. The tolerance is mandatory and sets the maximum allowed deviation; higher values produce more generalized lines. It can be used at the LAYER level or in CLASS STYLE. If generalization looks too aggressive, reduce tolerance; if it seems unchanged, verify you are not confusing pixel tolerances with map-unit tolerances (LAYER vs STYLE) and ensure the transform expression is correctly parenthesized. In debugging, also confirm you didn’t apply it after an operation that already reduced vertices (e.g., a prior simplify).",
    "keywords": [
      "generalize()",
      "ThinNoPoint",
      "GEOS dependency",
      "tolerance mandatory",
      "geometry simplification",
      "LAYER vs STYLE",
      "map units",
      "aggressive simplification",
      "expression parentheses",
      "transform order"
    ]
  },
  {
    "id": 69,
    "text": "MapServer 8.0 introduced inner([shape]) and outer([shape]) to derive rings from polygon inputs. inner() creates an inner corresponding ring; outer() creates an outer corresponding ring, which can help with label placement when you want to ignore islands or holes while labeling a lake. These transforms return new shapes derived from the polygon topology, so unexpected results often stem from invalid polygon geometry. If inner/outer yields strange rings, validate your datasource geometry (self-intersections, unclosed rings) and confirm the layer is truly polygonal before transforming; using them on non-polygons will not behave as intended.",
    "keywords": [
      "inner()",
      "outer()",
      "MapServer 8.0",
      "polygon rings",
      "ignore islands",
      "label placement",
      "invalid geometry",
      "holes",
      "topology",
      "ring debugging"
    ]
  },
  {
    "id": 70,
    "text": "GEOMTRANSFORM simplify([shape], tolerance) applies the Douglas–Peucker algorithm to reduce vertices; tolerance is mandatory and higher values simplify more. A common advanced example is simplifying a generated centerline for labeling, e.g. GEOMTRANSFORM (simplify((centerline([shape])), 10000)), then using LABEL ANGLE FOLLOW. If simplify removes important bends, lower the tolerance or densify first to retain shape detail before simplifying. When simplify appears inconsistent across outputs, remember that STYLE-level simplify runs in pixel space and can vary with map scale and RESOLUTION, while LAYER-level simplify runs in map units.",
    "keywords": [
      "simplify()",
      "Douglas-Peucker",
      "tolerance",
      "vertex reduction",
      "centerline simplify",
      "ANGLE FOLLOW",
      "scale dependence",
      "RESOLUTION",
      "pixel vs map units",
      "simplify tuning"
    ]
  },
  {
    "id": 71,
    "text": "GEOMTRANSFORM simplifypt([shape], tolerance) simplifies while preserving geometry validity and maintaining the same dimension and number of components as the input; tolerance must be non-negative. This is useful when downstream operations (like smoothing) require valid geometries and you can’t afford to create self-intersections or collapsed parts. If simplifypt fails, check for negative tolerances and validate the input geometry, since already-invalid shapes can still produce odd outcomes. In practice, simplifypt is often recommended as a preprocessing step before smoothsia when the dataset has very dense vertices at the target map scale.",
    "keywords": [
      "simplifypt()",
      "valid geometry",
      "non-negative tolerance",
      "preserve components",
      "preprocessing",
      "smoothsia",
      "dense vertices",
      "geometry validity",
      "error causes",
      "simplification safety"
    ]
  },
  {
    "id": 72,
    "text": "GEOMTRANSFORM smoothsia([shape], smoothing_size, smoothing_iterations, preprocessing) smooths line geometries. smoothing_size (default 3) is the window size, smoothing_iterations (default 1) repeats smoothing, and preprocessing can be 'all' (adds intermediate vertices) or 'angle' (adds vertices based on angle detection). When dataset resolution is too high (vertices very dense), smoothing may appear ineffective; simplifypt first (e.g., smoothsia(simplifypt([shape],10))). When resolution is too low, smoothing can lose acute angles—enable preprocessing 'all' to preserve shape. Debug by tuning parameters gradually and watching for increased vertex counts affecting render speed.",
    "keywords": [
      "smoothsia",
      "line smoothing",
      "smoothing_size",
      "smoothing_iterations",
      "preprocessing all",
      "preprocessing angle",
      "high resolution vertices",
      "low resolution loss",
      "simplifypt preprocessing",
      "performance tuning"
    ]
  },
  {
    "id": 73,
    "text": "GEOMTRANSFORM can call a JavaScript plugin to programmatically modify geometry: set GEOMTRANSFORM \"javascript://transform.js\" (relative) or \"javascript:///abs/path/transform.js\" (absolute). The script must implement a geomtransform() function that returns a new shape; only the returned geometry is used, while the original feature attributes are preserved and accessible via shape.attributes. Helper functions include alert(), print() for MapServer logs, and require() to include libraries. If scripts don’t run, check file path permissions and enable logging with MAP CONFIG \"MS_ERRORFILE\" and DEBUG to capture print() output and syntax errors.",
    "keywords": [
      "javascript geomtransform",
      "javascript:// path",
      "geomtransform() function",
      "shape.attributes",
      "print() logs",
      "require()",
      "MS_ERRORFILE",
      "DEBUG",
      "file permissions",
      "plugin troubleshooting"
    ]
  },
  {
    "id": 74,
    "text": "The JavaScript GEOMTRANSFORM API exposes minimal geometry classes for building new shapes. pointObj holds x/y (and optional z/m) and provides setXY/setXYZ. lineObj contains a list of points (numpoints read-only) and methods to access a point(index) or add points via add(), addXY(), addXYZ(). shapeObj is created with a type (Point, Line, Polygon, or Null), exposes read-only metadata (numlines, numvalues, classindex, tileindex), includes a text field and an attributes object, and can clone() or replace geometry with setGeometry(). If your script crashes, check you are creating the correct type and not indexing points/lines out of range.",
    "keywords": [
      "JavaScript API",
      "pointObj",
      "lineObj",
      "shapeObj",
      "setXY",
      "addXY",
      "geometry type",
      "attributes object",
      "clone()",
      "out of range index"
    ]
  },
  {
    "id": 75,
    "text": "The GRID object draws labeled graticule lines and is defined inside a LAYER, allowing multiple GRID blocks per layer (e.g., lat/long plus UTM). Key parameters include LABELFORMAT (DD, DDMM, DDMMSS, or a C-style format like %g°), MINARCS/MAXARCS (control how many arcs are drawn), MININTERVAL/MAXINTERVAL (grid spacing in the grid SRS units), and MINSUBDIVIDE/MAXSUBDIVIDE (segment count for curved arcs; default MAXSUBDIVIDE is 256). When GRID renders too dense or stalls, your interval settings may be too small—avoid extreme values like MININTERVAL 1 in meters, which can overload MapServer.",
    "keywords": [
      "GRID object",
      "graticule",
      "LABELFORMAT",
      "MININTERVAL",
      "MAXINTERVAL",
      "MINARCS",
      "MAXARCS",
      "MINSUBDIVIDE",
      "MAXSUBDIVIDE",
      "performance overload"
    ]
  },
  {
    "id": 76,
    "text": "IDENTIFY (added in 8.6) controls how features are picked for WMS GetFeatureInfo or MODE=QUERY. TOLERANCE sets sensitivity in TOLERANCEUNITS (default pixels); defaults are 3 for POINT/LINE and 0 for other types, and polygons can be restricted by setting tolerance to 0. Two precise modes exist for POINT layers using SYMBOL: CLASSAUTO uses the symbols from the rendering classes to identify non-transparent pixels, while CLASSGROUP uses symbols from a specified class GROUP. CLASSAUTO and CLASSGROUP are mutually exclusive, and both still use TOLERANCE to expand sensitive pixels. If identification seems wrong, confirm the layer TYPE, SYMBOL usage, and that GROUP strings match exactly.",
    "keywords": [
      "IDENTIFY",
      "MapServer 8.6",
      "GetFeatureInfo",
      "MODE=QUERY",
      "TOLERANCE",
      "TOLERANCEUNITS",
      "CLASSAUTO",
      "CLASSGROUP",
      "non-transparent pixels",
      "point layer identify"
    ]
  },
  {
    "id": 77,
    "text": "INCLUDE lets you split a mapfile into multiple files: when parsing hits INCLUDE 'file.map', MapServer immediately switches to that file, which may contain any valid mapfile syntax. Supported in 4.10+, the include filename must be quoted, nesting is allowed up to 5 levels, and paths can be absolute or (>=4.10.1) relative to the top-level mapfile. A common debugging pitfall is that errors don’t clearly report which included file failed, and the line counter is not reset per file. If you see msyylex(): Unable to access file opening an included file, verify the path and server permissions, and consider preprocessing includes into a single production mapfile for high-performance deployments.",
    "keywords": [
      "INCLUDE",
      "quoted filename",
      "nested includes",
      "relative to top-level",
      "msyylex unable to access",
      "debugging includes",
      "permissions",
      "mapfile modularization",
      "preprocessing",
      "MapServer 4.10"
    ]
  },
  {
    "id": 78,
    "text": "JOIN blocks (inside a LAYER) add lookup-table attributes for query results only—joins do not affect map rendering or styling because they are applied after a query is processed. Supported sources include DBF/XBase, CSV, PostgreSQL, and MySQL. Key parameters are NAME (required), TABLE, FROM and TO join columns (case sensitive), TYPE (ONE-TO-ONE or ONE-TO-MANY), CONNECTION/CONNECTIONTYPE for databases, and TEMPLATE/HEADER/FOOTER for query output. For CSV joins, MapServer’s CSV driver typically references columns by index (\"1\", \"2\", …) rather than header names, so templates use placeholders like [joinname_2]. One-to-many joins require a JOIN TEMPLATE and a layer template that expands [join_joinname].",
    "keywords": [
      "JOIN",
      "query-only",
      "ONE-TO-ONE",
      "ONE-TO-MANY",
      "FROM TO case sensitive",
      "CSV column index",
      "PostgreSQL join",
      "MySQL join",
      "query templates",
      "join placeholders"
    ]
  },
  {
    "id": 79,
    "text": "LABEL parameters control text layout and are a frequent source of rendering surprises and parsing errors. ALIGN (added 5.4) sets multiline alignment and can be driven by an attribute (added 7.6); using an integer attribute (1/2/3 for left/center/right) avoids slower string comparisons. ANGLE supports fixed degrees (-360..360), AUTO/AUTO2 for LINE layers, FOLLOW for curved labels, or an [ATTRIBUTE] holding angles. GD-specific ANTIALIAS was removed in 7.0 (GD output removed). Legacy label billboards such as BACKGROUNDCOLOR and BACKGROUNDSHADOW* were removed in 6.0—use LABEL STYLE with GEOMTRANSFORM labelpoly plus COLOR/OFFSET instead.",
    "keywords": [
      "LABEL",
      "ALIGN",
      "ANGLE",
      "AUTO2",
      "FOLLOW",
      "attribute-driven angle",
      "ANTIALIAS removed 7.0",
      "BACKGROUNDCOLOR removed 6.0",
      "labelpoly billboard",
      "parsing errors"
    ]
  },
  {
    "id": 80,
    "text": "LABEL color and font settings support both literals and data-driven values. COLOR/OUTLINECOLOR accept RGB triplets, hex strings (#rrggbb) and RGBA (#rrggbbaa) for translucency, or an [ATTRIBUTE] containing a color value. LABEL ENCODING was removed in 7.0 because MapServer internally uses UTF-8 and dataset encodings are handled with LAYER ENCODING; misconfigured encodings commonly cause labels to vanish. EXPRESSION (added 6.2) can conditionally apply a LABEL, similar to CLASS EXPRESSION. FONT references a FONTSET alias or an attribute; it can also be a comma-separated fallback font list (RFC80) and MapServer 7+ supports language-specific fonts (RFC98).",
    "keywords": [
      "LABEL COLOR",
      "hex RGBA",
      "OUTLINECOLOR",
      "attribute color",
      "LAYER ENCODING",
      "UTF-8",
      "LABEL EXPRESSION",
      "FONTSET alias",
      "fallback fonts RFC80",
      "language fonts RFC98"
    ]
  },
  {
    "id": 81,
    "text": "LABEL collision behavior is controlled by FORCE and text wrapping settings. FORCE true draws labels regardless of collisions (cached labels only); FORCE can also take a group value (added 6.2) so multiple labels/symbol styles for the same feature may intersect. MAXLENGTH interacts with WRAP: with a WRAP character, MapServer inserts line breaks at the first WRAP after MAXLENGTH characters; without WRAP, labels longer than MAXLENGTH may be skipped. In MapServer >= 8, MAXLENGTH must be >0—setting MAXLENGTH 0 can trigger strict validation errors. Negative MAXLENGTH behavior from older versions is not supported since 7; preprocess text instead.",
    "keywords": [
      "FORCE",
      "label collisions",
      "FORCE group 6.2",
      "MAXLENGTH",
      "WRAP",
      "MapServer 8 strict checks",
      "MAXLENGTH 0 error",
      "cached labels",
      "skip long labels",
      "text preprocessing"
    ]
  },
  {
    "id": 82,
    "text": "Scale and spacing rules often explain “missing labels”. MAXSCALEDENOM and MINSCALEDENOM define the scale interval where labels draw (denominator values, must be >=0). MAXOVERLAPANGLE filters out FOLLOW labels with overlapping characters; from 6.0 the default is 22.5 degrees, and setting it to 0 reverts to pre-6.0 behavior. MINDISTANCE sets minimum distance between duplicate labels (in pixels) and since 7.2 is computed from label boundaries instead of centers. MINFEATURESIZE (integer or AUTO) prevents labeling tiny features; AUTO labels only when the feature can fit its own label. If labels disappear, confirm these thresholds, the current map scale, and that values are >0 where required.",
    "keywords": [
      "MINSCALEDENOM",
      "MAXSCALEDENOM",
      "MAXOVERLAPANGLE",
      "FOLLOW overlap",
      "MINDISTANCE 7.2",
      "MINFEATURESIZE AUTO",
      "map scale",
      "missing labels",
      "thresholds",
      "label filtering"
    ]
  },
  {
    "id": 83,
    "text": "Label placement includes positioning, offsets, halos, and repeats. POSITION uses codes like ul/cc/lr and AUTO chooses a non-colliding position (cached labels only) with different candidate sets for points, polygons, and lines. OFFSET is in pixels and can be driven by integer attributes (since 7.6). With ANGLE FOLLOW, special OFFSET modes exist: x -99 shifts left/right of the feature and x 99 shifts above/below, depending on sign. OUTLINEWIDTH (halo) is supported for values >1 only in the AGG renderer, and PRIORITY must be 1–10 or MapServer raises a parsing error. REPEATDISTANCE repeats labels along lines. SIZE must be an integer because FreeType only accepts integers. LABEL STYLE supports GEOMTRANSFORM labelcenter/labelpnt/labelpoly for backgrounds and markers (not for FOLLOW labels).",
    "keywords": [
      "POSITION AUTO",
      "OFFSET",
      "OFFSET -99",
      "OFFSET 99",
      "OUTLINEWIDTH halo",
      "AGG renderer",
      "PRIORITY 1-10",
      "REPEATDISTANCE",
      "SIZE integer",
      "labelcenter labelpoly"
    ]
  },
  {
    "id": 84,
    "text": "BINDVALS (added in 6.0) allows mapfile variables to be bound as SQL parameters, which helps avoid SQL injection when building dynamic database queries. The intent is that MapServer will properly escape strings and integers when binding values into SQL statements. This mechanism applies to connections such as PostGIS and Oracle and is configured at the LAYER level. If a database query fails after adding BINDVALS, check that the placeholder names match your SQL, confirm the bound values are valid for the target column types, and ensure you are not mixing runtime substitution and bind variables in a way that changes quoting rules.",
    "keywords": [
      "BINDVALS",
      "MapServer 6.0",
      "SQL parameters",
      "SQL injection prevention",
      "PostGIS",
      "Oracle",
      "LAYER configuration",
      "placeholder mismatch",
      "type checking",
      "query debugging"
    ]
  },
  {
    "id": 85,
    "text": "Label blocks support TEXT expressions and font TYPE selection. TYPE can be bitmap or truetype; bitmap fonts draw faster but TrueType scales better and needs a FONT alias from the MAP FONTSET. WRAP controls multi-line labels by defining an end-of-line character and works with MAXLENGTH to insert line breaks after a threshold. Since 7.2.1 you can wrap on the Zero Width Space (U+200B) to break long strings without showing a visible delimiter (e.g., add it in PostGIS with replace(field,'-','\\u200b')). If wrapping or fonts fail, check FONTSET paths, renderer support for bitmap fonts, and avoid invalid MAXLENGTH values.",
    "keywords": [
      "LABEL WRAP",
      "MAXLENGTH",
      "Zero Width Space",
      "U+200B",
      "bitmap fonts",
      "truetype fonts",
      "FONTSET",
      "FONT alias",
      "multiline labels",
      "label troubleshooting"
    ]
  },
  {
    "id": 86,
    "text": "Inside a LAYER, features are tested against CLASS blocks in mapfile order. By default only the first class that matches both scale constraints and EXPRESSION will be used for rendering, which can surprise you when multiple classes could apply. MapServer 7.6+ adds the PROCESSING directive RENDERMODE to change this behavior: FIRST_MATCHING_CLASS keeps the legacy logic, while ALL_MATCHING_CLASSES draws every matching class on top of the previous ones (similar to SLD rendering). When styles seem “missing” or only one of several expected styles appears, confirm class order, scale denominators, and whether RENDERMODE was set.",
    "keywords": [
      "LAYER",
      "CLASS order",
      "FIRST_MATCHING_CLASS",
      "ALL_MATCHING_CLASSES",
      "RENDERMODE",
      "PROCESSING directive",
      "class precedence",
      "SLD behavior",
      "EXPRESSION",
      "scale constraints"
    ]
  },
  {
    "id": 87,
    "text": "CONNECTION supplies the database connection string used by remote datasources. For PostGIS it uses a PostgreSQL-style string (user, password, dbname, host, port); Oracle uses user/pass[@db]; older ArcSDE strings used comma-separated host/instance/db/user/password. MapServer’s native SDE driver was removed in 7.0, so SDE access now typically goes through OGR. If a layer that worked in older deployments stops connecting, verify CONNECTIONTYPE, confirm the driver still exists in your build, and check server credentials and network access before chasing mapfile syntax errors.",
    "keywords": [
      "CONNECTION",
      "PostGIS connection string",
      "Oracle connection",
      "ArcSDE removed",
      "MapServer 7.0",
      "OGR fallback",
      "CONNECTIONTYPE",
      "database credentials",
      "remote datasource",
      "connection debugging"
    ]
  },
  {
    "id": 88,
    "text": "CONNECTIONOPTIONS (added 7.6) lets you pass driver-specific open options as key/value pairs, currently for CONNECTIONTYPE OGR and some raster layers. A common case is GeoJSON, where you may enable options like FLATTEN_NESTED_ATTRIBUTES=YES to simplify attribute structures. Place CONNECTIONOPTIONS in the LAYER and terminate with END. If options appear ignored, confirm the underlying GDAL/OGR driver supports that option, ensure quoting and nesting are correct, and verify you did not accidentally set a conflicting option in the datasource URL itself.",
    "keywords": [
      "CONNECTIONOPTIONS",
      "MapServer 7.6",
      "OGR open options",
      "GDAL options",
      "GeoJSON",
      "FLATTEN_NESTED_ATTRIBUTES",
      "driver support",
      "layer nesting",
      "END token",
      "options ignored"
    ]
  },
  {
    "id": 89,
    "text": "DATA points MapServer to the spatial source: a filename (often relative to SHAPEPATH) or a database query. For PostGIS, DATA is usually “geom_column from table”; Oracle allows “shape FROM table” or subqueries. Subqueries can be slow because the BBOX filter may be applied only after the inner query runs. To filter earlier, you can use the !BOX! variable directly in the subquery (e.g., WHERE ST_Intersects(wkb_geometry,!BOX!)). If queries time out or maps draw slowly, review DATA complexity, prefer LAYER FILTER where possible, and test by intentionally triggering an error to see the SQL MapServer submits.",
    "keywords": [
      "DATA parameter",
      "SHAPEPATH",
      "PostGIS DATA syntax",
      "Oracle subquery",
      "BBOX filter",
      "!BOX! variable",
      "ST_Intersects",
      "performance tuning",
      "SQL debugging",
      "LAYER FILTER"
    ]
  },
  {
    "id": 90,
    "text": "LAYER DEBUG controls per-layer logging. In MapServer >=5, debug output is sent to STDERR or to the file set by the MS_ERRORFILE environment variable (which you can also set via MAP CONFIG or web server SetEnv). DEBUG 0 logs only errors, DEBUG 1 adds warnings about common pitfalls, DEBUG 2 adds notices and timing, and DEBUG 3 is the usual “mapfile troubleshooting” level (URLs called, DB connections, etc.). Higher levels add more internal details. If you see no logs, confirm MS_ERRORFILE is writable by the MapServer process and that DEBUG is enabled at the correct scope (MAP vs LAYER).",
    "keywords": [
      "LAYER DEBUG",
      "MS_ERRORFILE",
      "DEBUG levels",
      "STDERR logging",
      "MapServer >=5",
      "CONFIG MS_ERRORFILE",
      "SetEnv",
      "timing information",
      "WMS URL debug",
      "troubleshooting logs"
    ]
  },
  {
    "id": 91,
    "text": "ENCODING (added 7.0) belongs at the LAYER level to describe the datasource text encoding. When set (and not UTF-8), MapServer converts text to UTF-8 for outputs like GetCapabilities and query responses, but requires ICONV support. Mis-set encodings are a common reason for “labels vanished” or garbled characters. Separately, the DUMP parameter was removed in 8.0; use LAYER METADATA (e.g., WMS metadata keys) to control what items are exposed instead. When upgrading, watch for removed keywords that now trigger parse errors.",
    "keywords": [
      "LAYER ENCODING",
      "ICONV",
      "UTF-8 conversion",
      "international text",
      "labels missing",
      "DUMP removed 8.0",
      "LAYER METADATA",
      "upgrade parse errors",
      "GetCapabilities UTF-8",
      "encoding troubleshooting"
    ]
  },
  {
    "id": 92,
    "text": "EXTENT on a LAYER can override or shortcut datasource extent calculation. This is often used as an optimization for database layers where computing extents is expensive, but it can also cause confusing clipping if the values are wrong or in the wrong projection. If a layer draws only partially or disappears when panning, verify the EXTENT matches the datasource’s coordinate system and that min/max ordering is correct. For dynamic datasources, consider letting MapServer compute extents or maintain them externally to avoid stale hard-coded bounds.",
    "keywords": [
      "LAYER EXTENT",
      "extent optimization",
      "database layers",
      "clipping issues",
      "wrong projection",
      "minx miny maxx maxy",
      "panning disappears",
      "stale bounds",
      "performance",
      "extent debugging"
    ]
  },
  {
    "id": 93,
    "text": "FILTER applies attribute filtering at the same time as spatial filtering, before CLASS expressions are evaluated. This makes FILTER a good place to reduce feature counts early. Driver-specific native filters are provided via PROCESSING \"NATIVE_FILTER=id=234\" (added 7.0); older “FILTER 'where id=234'” syntax is no longer supported. If your filter seems ignored, check whether you used FILTERITEM + FILTER for simple cases (OGR and shapefiles only) versus a full expression in FILTER, and confirm runtime substitution didn’t inject invalid quotes or parentheses.",
    "keywords": [
      "LAYER FILTER",
      "filter order",
      "before CLASS",
      "NATIVE_FILTER",
      "PROCESSING",
      "FILTERITEM",
      "OGR shapefile only",
      "deprecated where syntax",
      "runtime substitution",
      "filter debugging"
    ]
  },
  {
    "id": 94,
    "text": "MASK restricts a layer so it is rendered only where it intersects features from another layer named by MASK. The mask layer can be vector or raster, and is often set to STATUS OFF so it doesn’t appear visually. Labeling has a subtle twist: only labels whose label point falls inside the unmasked area are added to the label cache, but glyphs may still render over masked-out areas. If masking seems inverted or labels leak, verify the referenced layer NAME, confirm the mask layer is in the same mapfile, and check scale ranges so the mask is actually active when you test.",
    "keywords": [
      "MASK",
      "layer intersection",
      "mask layer NAME",
      "STATUS OFF mask",
      "label point inside",
      "label cache",
      "rfc79",
      "clipping behavior",
      "inverted mask",
      "mask debugging"
    ]
  },
  {
    "id": 95,
    "text": "PROCESSING passes driver and rendering directives to a layer. For databases and OGR/PostGIS, CLOSE_CONNECTION=DEFER enables connection pooling (useful with FastCGI), while CLOSE_CONNECTION=ALWAYS forces closing after each use. For tiled maps, LABEL_NO_CLIP=True can keep label anchor points stable across tile boundaries, and POLYLINE_NO_CLIP=True can prevent dashed or symbolized line patterns from changing as extents change. If you see duplicate labels on adjacent tiles or “broken” dash patterns at tile edges, these no-clip directives are usually the first fix to try.",
    "keywords": [
      "PROCESSING",
      "CLOSE_CONNECTION",
      "connection pooling",
      "FastCGI",
      "LABEL_NO_CLIP",
      "POLYLINE_NO_CLIP",
      "tiled maps",
      "dash edge effects",
      "duplicate labels",
      "layer directives"
    ]
  },
  {
    "id": 96,
    "text": "For AGG rendering, the PROCESSING \"GAMMA=0.5\" option can tweak linear gamma for polygon rendering. The default polygon gamma is often 0.75 (overridable in OUTPUTFORMAT); lowering to around 0.5 can reduce faint outlines (“seams”) between adjacent polygons caused by anti-aliasing. Starting in 8.4, a GAMMA processing option is also available for rasters, with a default of 1.0. If you see hairline cracks between polygons, confirm your renderer, test different GAMMA values, and ensure the issue isn’t caused by reprojection precision or mismatched polygon edges.",
    "keywords": [
      "GAMMA",
      "PROCESSING",
      "AGG renderer",
      "polygon seams",
      "anti-aliasing outlines",
      "OUTPUTFORMAT override",
      "MapServer 8.4 rasters",
      "hairline cracks",
      "gamma tuning",
      "render troubleshooting"
    ]
  },
  {
    "id": 97,
    "text": "REQUIRES sets a boolean context expression based on the STATUS of other layers. It works like LABELREQUIRES: each [layername] token is replaced with 0/1 and then evaluated with logical operators. This is useful to automatically hide a layer when another is enabled (e.g., hide vector boundaries when a raster background is on). Testing confirms REQUIRES affects multiple access paths such as mode=map, WMS GetMap, MapScript, and map2img. If a layer unexpectedly never draws, check the referenced layer names, operator logic, and whether CGI requests are turning layers on/off differently than you assumed.",
    "keywords": [
      "REQUIRES",
      "layer context",
      "STATUS dependency",
      "boolean expression",
      "[layername] tokens",
      "WMS GetMap",
      "mode=map",
      "MapScript",
      "map2img",
      "visibility debugging"
    ]
  },
  {
    "id": 98,
    "text": "SCALETOKEN (added 6.4) enables scale-dependent string substitutions inside parameters such as DATA. You define a token NAME (e.g., %pri%) and a VALUES table mapping scale denominators to replacement strings. At render time, MapServer picks the appropriate value based on the current map scale and substitutes it into strings, allowing you to switch tables, columns, shapefiles, or even subquery filters by scale. If scale switching doesn’t happen, verify the denominators in VALUES are ordered correctly, confirm the request scale is what you think it is, and ensure the token appears exactly in the target string.",
    "keywords": [
      "SCALETOKEN",
      "MapServer 6.4",
      "scale-dependent substitution",
      "VALUES table",
      "token NAME",
      "DATA switching",
      "scale denominator",
      "multi-scale datasets",
      "string replacement",
      "debugging scale tokens"
    ]
  },
  {
    "id": 99,
    "text": "STATUS controls whether a layer is drawn: ON, OFF, or DEFAULT. DEFAULT keeps the layer enabled in ways that can be surprising: in CGI mode it cannot be turned off through normal request mechanisms, and in WMS server mapfiles layers with STATUS DEFAULT are always sent to clients. GROUP lets you refer to a set of layers by one name; if a group name appears in a CGI LAYERS parameter, all layers in the group are returned and individual layer STATUS values do not apply. When layers won’t turn off, double-check STATUS DEFAULT usage and GROUP interactions in your request URLs.",
    "keywords": [
      "STATUS DEFAULT",
      "STATUS ON OFF",
      "GROUP",
      "CGI LAYERS parameter",
      "WMS always sent",
      "layer toggling",
      "request behavior",
      "debugging visibility",
      "grouped layers",
      "web interfaces"
    ]
  },
  {
    "id": 100,
    "text": "STYLEITEM enables per-feature styling driven by an attribute (style string), automatic driver styling (AUTO), a JavaScript generator, or SLD documents. Attribute-based styles can contain a MapServer STYLE block, a full CLASS definition (for expressions, labels, multiple styles), or an OGR Style String. Since 8.2, STYLEITEM can read SLD from either a feature attribute (must end with the StyledLayerDescriptor closing tag) or from an external file using the sld:// prefix; metadata SLD_USE_FIRST_NAMEDLAYER controls NamedLayer selection. If styles don’t apply, verify the attribute content, the sld:// path, and that V8 MapScript is enabled for JavaScript sources.",
    "keywords": [
      "STYLEITEM",
      "per-feature styling",
      "OGR style string",
      "STYLE block string",
      "CLASS definition string",
      "SLD string 8.2",
      "sld:// file",
      "SLD_USE_FIRST_NAMEDLAYER",
      "JavaScript style generator",
      "V8 MapScript"
    ]
  },
  {
    "id": 101,
    "text": "TILEINDEX points to a tileindex file or layer used to break data into tiles; TILEITEM names the attribute holding each tile’s location (default “location”). For shapefile/raster tileindexes this is usually a shapefile of polygons; for CONNECTIONTYPE OGR any GDAL/OGR datasource can be used. Normally tile locations are relative to SHAPEPATH, and the layer’s DATA value may be appended. Starting with 6.4 (rasters) and 7.2 (vectors), tileindexes can contain tiles in different projections, but then you must set TILESRS to the attribute holding each tile’s SRS. If tiles fail to load, check path assembly and consistent attribute schemas.",
    "keywords": [
      "TILEINDEX",
      "TILEITEM",
      "TILESRS",
      "tiled datasets",
      "SHAPEPATH relative paths",
      "OGR tileindex",
      "mixed projections",
      "MapServer 7.2 vectors",
      "MapServer 6.4 rasters",
      "tile loading errors"
    ]
  },
  {
    "id": 102,
    "text": "TRANSFORM controls whether a layer’s coordinates are transformed into image space. With the default TRUE, MapServer treats coordinates as map coordinates and applies projection/extent transforms. With TRANSFORM FALSE, coordinates are interpreted in image/graphics coordinates, which is useful for fixed-position logos, scalebars, or inline features anchored to the image rather than the map. Since 4.10, you can also set an alternative origin (ul/uc/…/lr) and use UNITS pixels or percentages to anchor content relative to different corners, independent of image size. If a logo drifts or disappears, verify TRANSFORM, UNITS, and the chosen origin.",
    "keywords": [
      "TRANSFORM",
      "TRANSFORM FALSE",
      "image coordinates",
      "graphics origin",
      "ul uc lr codes",
      "inline features",
      "logos",
      "UNITS pixels",
      "UNITS percentages",
      "anchoring troubleshooting"
    ]
  },
  {
    "id": 103,
    "text": "UTFITEM and UTFDATA (added 7.0) support UTFGrid output by defining an ID attribute (UTFITEM) and a JSON template (UTFDATA) that exposes additional attributes. UTFDATA uses MapServer expression substitution (e.g., \"{\\\"id\\\":\\\"[fid]\\\",\\\"name\\\":\\\"[name]\\\"}\") so the grid keys map back to feature data. If UTFGrid output contains only numeric keys or no attributes, confirm UTFITEM is set, ensure UTFDATA is valid JSON after substitutions, and verify the output format is configured for UTFGrid. Quoting mistakes inside the JSON template are a common source of parse errors.",
    "keywords": [
      "UTFGRID",
      "UTFITEM",
      "UTFDATA",
      "MapServer 7.0",
      "JSON template",
      "attribute exposure",
      "expression substitution",
      "quoting errors",
      "interactive grids",
      "output format"
    ]
  },
  {
    "id": 104,
    "text": "LAYER TYPE controls how features are rendered and does not have to match the datasource geometry type (e.g., polygons can be drawn as points). TYPE CIRCLE is special: circles are defined by a minimum bounding rectangle, usually by providing two opposite corners in an inline FEATURE POINTS block. TYPE QUERY means the layer can be queried but not drawn. Older TYPE ANNOTATION is deprecated since 6.2; equivalent behavior is achieved by using LABEL-level STYLE blocks, avoiding the old pattern of loading the same dataset twice. If a layer won’t draw, confirm TYPE is compatible with the intended symbolization and that required STYLE COLOR or OUTLINECOLOR is present.",
    "keywords": [
      "LAYER TYPE",
      "TYPE CIRCLE",
      "bounding rectangle",
      "TYPE QUERY",
      "TYPE ANNOTATION deprecated",
      "LABEL STYLE blocks",
      "polygon as point",
      "missing COLOR",
      "rendering rules",
      "type troubleshooting"
    ]
  },
  {
    "id": 105,
    "text": "The LEADER object (since 6.2, RFC 81) draws a line connecting a label to its feature when the label must be placed away from the geometry (common with small polygons and large text). It is nested under CLASS, alongside LABEL, and supports POINT/LINE/POLYGON layers. GRIDSTEP sets the pixel spacing between candidate positions tested for placing the leader, and MAXDISTANCE sets how far the label may be displaced while still drawing a leader line. STYLE inside LEADER controls the line’s COLOR and WIDTH. If leaders never appear, confirm LEADER is nested correctly and that GRIDSTEP/MAXDISTANCE are >0.",
    "keywords": [
      "LEADER",
      "RFC 81",
      "leader lines",
      "GRIDSTEP",
      "MAXDISTANCE",
      "label displacement",
      "CLASS nesting",
      "STYLE in LEADER",
      "small polygons",
      "leader troubleshooting"
    ]
  },
  {
    "id": 106,
    "text": "LEGEND controls legend rendering, including embedded legends. The legend image size is not known before it is built, so templates should avoid hard-coding <IMG> width/height. IMAGECOLOR sets the legend background (RGB or hex, including RGBA for translucency). KEYSIZE and KEYSPACING control symbol box size and spacing, with enforced min/max ranges. OUTLINECOLOR styles symbol key box outlines, POSITION chooses where an embedded legend appears (ul/…/lr), and STATUS determines whether to create the legend (on/off/embed). If embedded legends cover map content or appear with wrong colors, check POSITION, background transparency (TRANSPARENT), and template assumptions.",
    "keywords": [
      "LEGEND",
      "embedded legend",
      "IMAGECOLOR",
      "KEYSIZE",
      "KEYSPACING",
      "OUTLINECOLOR",
      "POSITION",
      "STATUS embed",
      "TRANSPARENT flag",
      "template sizing"
    ]
  },
  {
    "id": 107,
    "text": "MAP ANGLE rotates the entire map clockwise (range -360 to 360) and interacts with labeling and symbols. Map rotation requires a MAP-level PROJECTION and a PROJECTION for each LAYER (even if identical), and it requires MapScript (SWIG/PHP MapScript); it does not work in CGI mode. For labels, if you also set a LABEL OBJECT’s ANGLE or legacy LAYER LABELANGLEITEM, their values are computed relative to the map rotation, which can lead to counter-rotated text if you expect absolute angles. Similarly, STYLE ANGLE for point symbols (7.2+) becomes relative to MAP ANGLE. If rotation seems ignored, confirm you are not using CGI and that ANGLE is non-zero (use 0.0001 instead of 0 to force evaluation).",
    "keywords": [
      "MAP ANGLE",
      "map rotation",
      "clockwise rotation",
      "CGI mode limitation",
      "MapScript required",
      "PROJECTION required",
      "label angle relative",
      "STYLE ANGLE relative",
      "-360 to 360",
      "rotation troubleshooting"
    ]
  },
  {
    "id": 108,
    "text": "MAP CONFIG sets key/value pairs at runtime for MapServer and underlying GDAL/OGR libraries. It is commonly used to set environment variables such as MS_ERRORFILE for logging, or to pass GDAL configuration options without modifying the server’s global environment. CONFIG is especially helpful when debugging in environments where you can’t edit the web server configuration. If a setting appears ineffective, check whether your global configuration file or process environment overrides it, and remember that some security-sensitive variables (like mapfile path restrictions) may be managed in the required MapServer 8.x global config instead of per-mapfile CONFIG.",
    "keywords": [
      "MAP CONFIG",
      "runtime configuration",
      "environment variables",
      "GDAL config",
      "OGR config",
      "MS_ERRORFILE",
      "per-mapfile settings",
      "global config override",
      "debugging deployment",
      "security restrictions"
    ]
  },
  {
    "id": 109,
    "text": "The MAP object is the top-level container of a mapfile: it starts with the token MAP and must end with END. MAP sets global defaults such as EXTENT, SIZE, IMAGETYPE, SHAPEPATH, and SYMBOLSET, and it can include nested objects like WEB, LAYER, PROJECTION, OUTPUTFORMAT, LEGEND, SCALEBAR, and QUERYMAP. In MapServer 8.x several legacy MAP parameters were removed (e.g., DATAPATTERN, TEMPLATEPATTERN, IMAGEQUALITY, INTERLACE, TRANSPARENT) and their behavior moved to VALIDATION or OUTPUTFORMAT FORMATOPTION/TRANSPARENT. When upgrading, “unknown identifier” parse errors often mean a removed MAP keyword still exists in your mapfile.",
    "keywords": [
      "MAP object",
      "mapfile top-level",
      "MAP END",
      "EXTENT",
      "IMAGETYPE",
      "SHAPEPATH",
      "SYMBOLSET",
      "removed in 8.0",
      "DATAPATTERN",
      "TRANSPARENT moved",
      "upgrade parse error"
    ]
  },
  {
    "id": 110,
    "text": "MAP CONFIG provides runtime key/value settings for MapServer and GDAL/OGR. Useful keys include CGI_CONTEXT_URL (load a map context from a URL), MS_ENCRYPTION_KEY (for msencrypt), and MS_ERRORFILE for log output. MS_ERRORFILE requires an absolute path when set as an environment variable, but in MapServer 6.0+ a relative path may be given via CONFIG and is interpreted relative to the mapfile location. MS_NONSQUARE enables non-square pixels but requires PROJECTION at MAP and for each LAYER. ON_MISSING_DATA controls tileindex missing files: FAIL (default), LOG (needs DEBUG and MS_ERRORFILE), or IGNORE.",
    "keywords": [
      "MAP CONFIG",
      "CPLSetConfigOption",
      "MS_ERRORFILE",
      "relative path 6.0",
      "CGI_CONTEXT_URL",
      "MS_ENCRYPTION_KEY",
      "MS_NONSQUARE",
      "non-square pixels",
      "ON_MISSING_DATA",
      "tileindex missing files"
    ]
  },
  {
    "id": 111,
    "text": "DEBUG controls verbosity for troubleshooting. In MapServer 5.0+ debug output goes to STDERR or to the file configured by MS_ERRORFILE; you can set MS_ERRORFILE using MAP CONFIG or a web server SetEnv directive. DEBUG 0/OFF logs only msSetError() calls, while DEBUG 1 adds warnings, DEBUG 2 adds notices and timing, and DEBUG 3 is the common “mapfile troubleshooting” level (URLs called, database connections, etc.). DEBUG 4–5 add progressively more internal detail. You can also drive verbosity with the MS_DEBUGLEVEL environment variable, and DEBUG can be set per LAYER to focus logging.",
    "keywords": [
      "DEBUG",
      "MS_ERRORFILE",
      "STDERR logging",
      "DEBUG 0-5",
      "msDebug output",
      "timing information",
      "WMS URL logging",
      "database connection debug",
      "MS_DEBUGLEVEL",
      "layer-level DEBUG"
    ]
  },
  {
    "id": 112,
    "text": "MAP image sizing and background color can cause confusing transparency results. MAXSIZE limits output dimensions (default 4096 in MapServer >=7.0.3) and SIZE must be below MAXSIZE. IMAGECOLOR initializes the map background; for paletted outputs with transparency enabled in OUTPUTFORMAT, IMAGECOLOR is marked transparent in the palette, so any feature drawn in that same color will also become transparent. IMAGECOLOR accepts RGB triplets or hex strings, including RGBA (#rrggbbaa) when supported. If transparent maps have “holes” in unexpected places, choose a unique background color not used elsewhere and confirm which OUTPUTFORMAT is selected by IMAGETYPE.",
    "keywords": [
      "MAXSIZE",
      "SIZE limits",
      "IMAGECOLOR",
      "palette transparency",
      "OUTPUTFORMAT TRANSPARENT",
      "IMAGETYPE selection",
      "RGBA hex",
      "unexpected holes",
      "background color",
      "MapServer 7.0.3 default"
    ]
  },
  {
    "id": 113,
    "text": "OUTPUTFORMAT blocks define which output types MapServer can return (PNG, JPEG, PDF, SVG, GeoTIFF, KML, UTFGrid, etc.). A mapfile can declare zero or more OUTPUTFORMAT objects; if none are present, MapServer creates a set of implicit defaults such as png, png8, jpeg, svg, pdf, GTiff, kml/kmz, and a UTFGRID example. Availability depends on compile-time support: GeoTIFF needs GDAL, and PDF/SVG need Cairo. When a request fails with “imagetype not supported” or produces a different format than expected, check the IMAGETYPE value matches an OUTPUTFORMAT NAME and confirm your build supports the requested driver.",
    "keywords": [
      "OUTPUTFORMAT",
      "implicit defaults",
      "IMAGETYPE",
      "png png8 jpeg",
      "pdf svg",
      "GTiff",
      "KML KMZ",
      "UTFGRID",
      "compile-time support",
      "Cairo",
      "GDAL dependency"
    ]
  },
  {
    "id": 114,
    "text": "Each OUTPUTFORMAT specifies DRIVER, IMAGEMODE, MIMETYPE, EXTENSION, and optional FORMATOPTION lines. DRIVER names often include the backend and format, e.g., AGG/PNG, AGG/JPEG, CAIRO/PDF, CAIRO/SVG, GDAL/GTiff, or OGR/<driver>. IMAGEMODE selects how pixels are produced: RGB (no transparency), RGBA (alpha transparency), or raw modes like BYTE/INT16/FLOAT32 for raster/WMS outputs; FEATURE indicates non-image output (templates or OGR feature output). Transparency is controlled by OUTPUTFORMAT TRANSPARENT and does not work with IMAGEMODE RGB. If alpha blending is missing, verify IMAGEMODE and TRANSPARENT are compatible.",
    "keywords": [
      "OUTPUTFORMAT DRIVER",
      "AGG/PNG",
      "CAIRO/PDF",
      "GDAL/GTiff",
      "IMAGEMODE",
      "RGB vs RGBA",
      "BYTE INT16 FLOAT32",
      "FEATURE mode",
      "TRANSPARENT",
      "MIMETYPE"
    ]
  },
  {
    "id": 115,
    "text": "FORMATOPTION provides driver-specific tuning. For AGG/JPEG, QUALITY=0–100 controls compression quality. For AGG/PNG, COMPRESSION=0–9 sets zlib compression (default often 6). AGG/PNG also supports quantizing 24/32-bit images to 8-bit palettes: QUANTIZE_FORCE=on and QUANTIZE_COLORS=256 (max 256). For tighter control you can supply a PALETTE file containing 256 r,g,b triplets (or r,g,b,a quadruplets) one per line; to preserve transparency, include fully transparent 0,0,0,0 and opaque white 255,255,255,255 entries. If quantized maps look banded or lose anti-aliasing, revisit palette strategy and color count.",
    "keywords": [
      "FORMATOPTION",
      "AGG/JPEG QUALITY",
      "AGG/PNG COMPRESSION",
      "QUANTIZE_FORCE",
      "QUANTIZE_COLORS",
      "PALETTE file",
      "RGBA palette",
      "banding artifacts",
      "anti-aliasing",
      "zlib compression"
    ]
  },
  {
    "id": 116,
    "text": "AGG/MIXED is a meta driver (added 7.2) that chooses between two other formats depending on whether the rendered image contains transparency. You must set FORMATOPTION TRANSPARENT_FORMAT=<name> and OPAQUE_FORMAT=<name> to valid OUTPUTFORMAT names handled by AGG/PNG, AGG/JPEG, or GDAL drivers. The built-in jpeg_png formats demonstrate this: when the map has any non-opaque pixels it returns PNG (or PNG8), otherwise it returns JPEG to reduce file size. If MIXED always returns the same format, confirm the chosen IMAGEMODE is RGBA, the referenced formats exist, and that no forced background fill removed all transparency.",
    "keywords": [
      "AGG/MIXED",
      "MapServer 7.2",
      "TRANSPARENT_FORMAT",
      "OPAQUE_FORMAT",
      "jpeg_png",
      "png8 fallback",
      "opacity detection",
      "file size optimization",
      "IMAGEMODE RGBA",
      "mixed output troubleshooting"
    ]
  },
  {
    "id": 117,
    "text": "Some OUTPUTFORMAT options target specific backends. For CAIRO/PDF you can request Geospatial PDF output via GEO_ENCODING=ISO32000 or GEO_ENCODING=OGC_BP (requires GDAL with the PDF driver), and you can embed PDF metadata using FORMATOPTION METADATA_ITEM:<key>=<value> (AUTHOR, TITLE, SUBJECT, etc.). For GDAL/GTiff, common options include TILED=YES, BLOCKXSIZE/BLOCKYSIZE, INTERLEAVE, and COMPRESS settings, plus NULLVALUE for raw imagemodes to pre-initialize nodata. UTFGRID output supports options like LABELS=true, UTFRESOLUTION, and DUPLICATES=false. When a format ignores options, verify they are valid for that driver and spelled exactly.",
    "keywords": [
      "CAIRO/PDF",
      "Geospatial PDF",
      "GEO_ENCODING",
      "METADATA_ITEM",
      "GDAL/GTiff options",
      "TILED=YES",
      "COMPRESS",
      "NULLVALUE",
      "UTFGRID options",
      "driver option troubleshooting"
    ]
  },
  {
    "id": 118,
    "text": "PROJECTION blocks define reprojection using the PROJ library. When PROJ 6+ is used (MapServer 8+), using EPSG codes is recommended for accuracy (e.g., init=epsg:26915, init=epsg:4326, init=epsg:3857 for Web Mercator). The epsg filename is case-sensitive on Unix-like systems, so use lowercase “epsg” in init strings. PROJECTION AUTO is valid only for OGR, shapefile, and raster layers and reads projection from the datasource (.prj or GDAL metadata); for tileindexes with mixed projections, set TILESRS to the attribute naming each tile’s SRS. If you get msProjectRect() errors, double-check MAP output projection, EXTENT/UNITS, and each layer’s source projection. Ensure CONFIG \"PROJ_DATA\" appears before PROJECTION.",
    "keywords": [
      "PROJECTION",
      "PROJ library",
      "EPSG codes",
      "init=epsg",
      "case-sensitive epsg",
      "Web Mercator 3857",
      "PROJECTION AUTO",
      "TILESRS",
      "msProjectRect error",
      "PROJ_DATA ordering"
    ]
  },
  {
    "id": 119,
    "text": "QUERYMAP controls the “query result” image in classic CGI/query workflows. STYLE can be NORMAL (draw everything normally), HILITE (draw selected features with QUERYMAP COLOR while others remain normal), or SELECTED (draw only selected features). QUERYMAP SIZE defaults to the MAP SIZE, but supports -1 values to hide the querymap. REFERENCE defines a separate reference map (often for an overview inset) and supports drawing a box for the current map extent; if the box becomes too small, it switches to a MARKER symbol with MARKERSIZE based on MINBOXSIZE, and if the box is too large it can draw nothing (MAXBOXSIZE). REFERENCE IMAGE must be a GIF. If the reference box never appears, check STATUS, SIZE limits, and marker constraints.",
    "keywords": [
      "QUERYMAP",
      "HILITE",
      "SELECTED",
      "query highlight color",
      "querymap SIZE -1",
      "REFERENCE map",
      "MARKER",
      "MINBOXSIZE",
      "MAXBOXSIZE",
      "GIF reference image"
    ]
  },
  {
    "id": 120,
    "text": "SCALEBAR creates a graphic scale bar using the MAP UNITS and requested scale denominator. MapServer’s scalebar uses simple cartesian distances (no ellipsoidal geodesic correction) and currently does not use TrueType fonts, so label appearance differs from FreeType labels. Because the scalebar image size is not known until render time, templates should avoid hard-coding <IMG> width/height. Key controls include INTERVALS, ALIGN, SIZE, OUTLINECOLOR, and UNITS (decimal degrees are not valid). OFFSET (7.2) shifts the embedded scalebar relative to POSITION with a -50..50 pixel range, and POSTLABELCACHE embeds after label drawing. STATUS EMBED requires a markerset. TRANSPARENT can override the map’s output transparency for the scalebar.",
    "keywords": [
      "SCALEBAR",
      "cartesian distance",
      "no TrueType fonts",
      "template sizing",
      "INTERVALS",
      "POSITION",
      "OFFSET 7.2",
      "POSTLABELCACHE",
      "STATUS EMBED",
      "TRANSPARENT override"
    ]
  },
  {
    "id": 121,
    "text": "STYLE controls symbolization and is often where subtle rendering bugs hide. ANGLE rotates symbols counter-clockwise; for decorated lines, ANGLE behavior depends on GAP: with negative GAP the symbol rotates relative to the line tangent, while with non-negative GAP it rotates around its own center. Attribute-driven rotation uses ANGLE [ATTR] (ANGLEITEM was removed in 8.0). GAP (moved into STYLE in 6.0) sets symbol spacing in SIZEUNITS; its meaning stabilized in 6.2 as a center-to-center distance. INITIALGAP (6.2) offsets the first dash or first symbol for PATTERN/GAP styling. PATTERN lists alternating dash and gap lengths and must be terminated with END; missing PATTERN END is a common mapfile parsing error.",
    "keywords": [
      "STYLE",
      "ANGLE",
      "ANGLE [ATTR]",
      "decorated lines",
      "GAP negative",
      "INITIALGAP",
      "PATTERN",
      "PATTERN END",
      "SIZEUNITS",
      "MapServer 8.0 ANGLEITEM removed"
    ]
  },
  {
    "id": 122,
    "text": "STYLE also supports advanced, data-driven effects. COLOR and OUTLINECOLOR accept RGB/hex values or [ATTRIBUTE] values; if COLOR is omitted (and the symbol is not a pixmap) nothing is rendered. COLORRANGE/DATARANGE plus RANGEITEM map numeric attributes into a linear gradient (used for heatmaps or thematic rasters). POLAROFFSET (6.2) shifts symbols using radius and angle (both can be attributes), and uvraster layers expose special attributes like uv_length and uv_angle for drawing vector-field arrows. SIZE can be a constant, [ATTRIBUTE], or (since 8.2) an expression like SIZE ([HEIGHT] * 2), which must return a number. SYMBOL can be a named symbol, an index, a file path, an http URL for pixmaps, or an [ATTRIBUTE] selecting a per-feature symbol.",
    "keywords": [
      "COLORRANGE",
      "DATARANGE",
      "RANGEITEM",
      "POLAROFFSET",
      "uvraster attributes",
      "uv_angle",
      "SIZE expression 8.2",
      "SYMBOL URL",
      "per-feature SYMBOL attribute",
      "nothing rendered without COLOR"
    ]
  },
  {
    "id": 123,
    "text": "STYLEITEM with a JavaScript source lets you generate styling programmatically instead of relying on static CLASS/STYLE rules. You declare it in a LAYER as STYLEITEM \"javascript://myscript.js\" (relative path) or an absolute javascript:/// path, and the script outputs style definitions for each feature at render time. This approach is useful when styling logic is too complex for expressions or when you want to share a single styling function across multiple layers. For troubleshooting, ensure the script path is readable by the MapServer process, and increase logging (MS_ERRORFILE + DEBUG) so any JavaScript errors or diagnostic print() messages are captured in the MapServer logs.",
    "keywords": [
      "STYLEITEM",
      "JavaScript styling",
      "javascript:// path",
      "per-feature styles",
      "programmatic rendering",
      "complex styling logic",
      "MS_ERRORFILE",
      "DEBUG",
      "script permissions",
      "runtime errors"
    ]
  },
  {
    "id": 124,
    "text": "STYLEITEM can load a JavaScript plugin to compute styling per feature at draw time, instead of relying on static CLASS expressions. In a LAYER, set STYLEITEM to a javascript:// URL (relative) or javascript:/// absolute path. MapServer calls a required function named styleitem() for each feature, and the returned text is parsed as either a STYLE block or a CLASS block containing one or more STYLE blocks. Because the result applies to a single feature, the returned CLASS must not contain an EXPRESSION, and the LAYER should not define CLASSITEM. An empty CLASS block in the mapfile is mandatory.",
    "keywords": [
      "STYLEITEM",
      "JavaScript",
      "styleitem()",
      "javascript://",
      "per-feature styling",
      "empty CLASS",
      "no EXPRESSION",
      "no CLASSITEM",
      "mapfile syntax",
      "runtime styling"
    ]
  },
  {
    "id": 125,
    "text": "In a STYLEITEM JavaScript plugin, feature attributes are accessible through the shape.attributes object, so you can build rules like “size based on NAME length”. The helper functions alert() and print() write messages into MapServer logs, which helps debug wrong symbology or script errors; require() can load additional JavaScript libraries. Since every feature triggers a call into the script, inefficient logic can slow rendering noticeably. If debugging output is missing, confirm MAP CONFIG \"MS_ERRORFILE\" is set and DEBUG is enabled so the server actually writes the log file.",
    "keywords": [
      "shape.attributes",
      "alert()",
      "print()",
      "require()",
      "MS_ERRORFILE",
      "DEBUG",
      "performance",
      "logging",
      "script errors",
      "MapServer logs"
    ]
  },
  {
    "id": 126,
    "text": "Symbol definitions describe geometry only; they do not store color. Colors and widths are set in STYLE blocks inside CLASS. Symbols can be embedded in the main mapfile, but most deployments keep them in a separate symbolset file referenced by the MAP-level SYMBOLSET keyword to reuse symbols across applications. MapServer broadly supports marker, line, and shade (fill) symbols. Symbol 0 is a special degenerate default (single pixel point, solid polygon fill, single-pixel line). If you see an unexpected default look, check for missing SYMBOL references or symbolset loading errors.",
    "keywords": [
      "SYMBOL",
      "SYMBOLSET",
      "symbolset file",
      "marker",
      "line symbol",
      "shade symbol",
      "symbol 0",
      "STYLE COLOR",
      "missing symbol",
      "reuse definitions"
    ]
  },
  {
    "id": 127,
    "text": "SYMBOL parameters often explain rendering surprises. TYPE may be ellipse, vector, hatch, pixmap, svg, or truetype. For truetype symbols, FONT must exist in FONTSET and CHARACTER selects the glyph (keyboard character or an HTML entity number). FILLED controls whether ellipse/vector are filled polygons (COLOR + OUTLINECOLOR + WIDTH) or stroked lines (COLOR + WIDTH). Pixmap symbols can use TRANSPARENT for a color index, but some renderers do not honor it; SVG symbols may require width/height inside the SVG for correct anchoring. Older GD-only options like ANTIALIAS may not apply in newer builds.",
    "keywords": [
      "SYMBOL TYPE",
      "truetype",
      "FONTSET",
      "CHARACTER",
      "FILLED",
      "pixmap",
      "TRANSPARENT",
      "svg width/height",
      "ANCHORPOINT",
      "ANTIALIAS"
    ]
  },
  {
    "id": 128,
    "text": "A dashed line is created with a STYLE that uses PATTERN. PATTERN values are alternating on/off lengths (in SIZEUNITS) and must end with END. Combine it with WIDTH and (optionally) LINECAP to control dash thickness and end shape. If the line renders solid, common causes are: PATTERN placed outside the STYLE block, missing the PATTERN END terminator, or WIDTH evaluating to 0 at the current scale. “Parse error near PATTERN” usually indicates a missing END somewhere earlier in the CLASS/STYLE nesting.",
    "keywords": [
      "dashed line",
      "PATTERN",
      "LINECAP",
      "WIDTH",
      "SIZEUNITS",
      "STYLE nesting",
      "missing END",
      "parse error",
      "line symbology",
      "MapServer"
    ]
  },
  {
    "id": 129,
    "text": "TrueType marker symbols draw a font glyph as a symbol. Define a SYMBOL with TYPE TRUETYPE, set FONT to a name in your FONTSET, and choose CHARACTER (often as an HTML entity like \"&#10140;\"). If the glyph shows as a blank box, verify the font name, confirm the font file is readable by the MapServer process, and double-check the character code mapping. Historically, ANTIALIAS was needed for GD output, but modern renderers handle anti-aliasing differently. Testing the same symbol in a minimal mapfile can isolate font and path problems.",
    "keywords": [
      "TYPE TRUETYPE",
      "FONTSET",
      "CHARACTER entity",
      "glyph mapping",
      "font permissions",
      "missing glyph",
      "ANTIALIAS",
      "marker symbol",
      "debugging",
      "minimal mapfile"
    ]
  },
  {
    "id": 130,
    "text": "Vector and ellipse symbols are built from POINTS. A triangle needs the first and last point to match to close the shape. To create multiple disconnected segments (like a cross), insert a separator point such as -99 -99 between segments. Ellipse symbols can be defined with a single POINTS entry (e.g., 1 1) and FILLED true for a circle-like marker. If a symbol’s size looks wrong, remember that when a STYLE omits SIZE, MapServer may infer a default size from the symbol’s coordinate range. Always close POINTS with END and the SYMBOL with END to avoid parser errors.",
    "keywords": [
      "TYPE vector",
      "TYPE ellipse",
      "POINTS",
      "-99 -99",
      "disconnected segments",
      "default SIZE",
      "FILLED",
      "symbol geometry",
      "END blocks",
      "parse errors"
    ]
  },
  {
    "id": 131,
    "text": "Hatched polygon fills use a SYMBOL of TYPE HATCH and are controlled from STYLE. Typical STYLE settings are SYMBOL, COLOR, ANGLE (direction), SIZE (spacing), and WIDTH (stroke thickness). HATCH also supports limits like MINSIZE/MAXSIZE and MINWIDTH/MAXWIDTH to clamp values across scale changes. If hatching disappears or becomes too dense at certain scales, check your SIZEUNITS settings and whether the min/max constraints are filtering out the current SIZE or WIDTH. Large hatched polygons can be expensive to render, so keep patterns simple when performance matters.",
    "keywords": [
      "TYPE HATCH",
      "hatched fill",
      "ANGLE",
      "SIZE spacing",
      "WIDTH thickness",
      "MINSIZE",
      "MAXSIZE",
      "MINWIDTH",
      "MAXWIDTH",
      "render performance"
    ]
  },
  {
    "id": 132,
    "text": "Lines can be “decorated” by stacking multiple STYLE blocks in a single CLASS: one STYLE draws the base line, and another places a repeated symbol along the line. GAP controls spacing between placed symbols; a negative GAP makes symbol orientation follow the line direction, which is useful for arrows or elongated ellipses. The symbol STYLE can also set ANGLE and SIZE to rotate and scale the markers. When symbols do not appear, check that the symbol name is correct, the second STYLE block is present, and GAP/size values are sensible at the current scale.",
    "keywords": [
      "multiple STYLE",
      "line decoration",
      "GAP",
      "negative GAP",
      "symbol along line",
      "ANGLE",
      "SIZE",
      "CLASS styling",
      "missing symbols",
      "scale issues"
    ]
  },
  {
    "id": 133,
    "text": "Templates define the output for CGI map browsing and for presenting query results. Templates are usually files, but can also be URL templates; URL templates only work for simple QUERY/ITEMQUERY results and support fewer substitutions. A template must contain the magic string “mapservertemplate” on its first line (often inside an HTML/XML/JS comment), and MapServer only accepts a limited set of template extensions (e.g., .html, .xml, .tmpl, .svg, .kml, .js). If MapServer refuses a template, the first things to check are the magic string, the file extension, and file permissions.",
    "keywords": [
      "templating",
      "mapservertemplate",
      "CGI interface",
      "query output",
      "template extensions",
      "URL template",
      "permissions",
      "file path",
      "MapServer CGI",
      "HTML templates"
    ]
  },
  {
    "id": 134,
    "text": "General template substitutions provide request and server context. [date] outputs server time and supports format= (strftime) and tz= (gmt/local). [version] returns the MapServer version. [id] is a session identifier (often based on time and process id). [host] and [port] expose the web server endpoint. Any GET/POST parameter can be echoed back using [varname] or [varname_esc], which is useful for persisting form state and debugging missing parameters. If a substitution outputs nothing, verify the CGI parameter name and confirm it is actually present in the request.",
    "keywords": [
      "[date]",
      "strftime",
      "tz=",
      "[version]",
      "[id]",
      "[host]",
      "[port]",
      "[varname]",
      "_esc",
      "template debugging"
    ]
  },
  {
    "id": 135,
    "text": "File-reference substitutions point to images and saved artifacts generated by MapServer. [img] expands to the main map image path (or just the filename if WEB.IMAGEURL is not set). [ref] is the reference map image, [legend] the legend image, and [scalebar] the scalebar image. Query workflows may also expose [queryfile] (saved query) and [map] (saved mapfile) when those CGI options are used. If browsers return 404 for these resources, check that WEB.IMAGEPATH is writable, WEB.IMAGEURL maps to that directory, and your web server serves the directory that IMAGEURL points to.",
    "keywords": [
      "[img]",
      "[ref]",
      "[legend]",
      "[scalebar]",
      "IMAGEPATH",
      "IMAGEURL",
      "404 troubleshooting",
      "queryfile",
      "savemap",
      "deployment"
    ]
  },
  {
    "id": 136,
    "text": "Image-geometry substitutions help implement pan/zoom interfaces. [center] (or [center_x]/[center_y]) is the computed image center in pixels. [mapsize] returns current width/height, while [mapwidth] and [mapheight] return single values. [scaledenom] is the current scale denominator. [mapext] returns the fitted map extent and supports escape= (url/none), expand= (buffer extents in map units), format= (tokenized output), and precision=. [rawext] returns the pre-fit extent before window fitting. Wrong extent formatting often causes broken links in templates, so echo these tags when debugging.",
    "keywords": [
      "[center]",
      "[mapsize]",
      "[mapwidth]",
      "[mapheight]",
      "[scaledenom]",
      "[mapext]",
      "expand=",
      "precision=",
      "rawext",
      "pan/zoom"
    ]
  },
  {
    "id": 137,
    "text": "Projection-dependent substitutions require MapServer to be compiled with PROJ support and for PROJECTION blocks to be defined. [maplon] and [maplat] can return the lon/lat of a mouse click. [mapext_latlon] returns the current map extent in geographic coordinates, with the same escape/format/precision options. [refext] exposes the reference map extent and supports expand= and escape=. If these tags fail or return empty strings, check that PROJECTION is set at the MAP and LAYER levels as needed, and confirm SRS definitions are valid and consistent across layers.",
    "keywords": [
      "PROJ",
      "PROJECTION",
      "[maplon]",
      "[maplat]",
      "mapext_latlon",
      "refext",
      "coordinate transform",
      "compile support",
      "SRS errors",
      "template tags"
    ]
  },
  {
    "id": 138,
    "text": "Templates can persist layer selections and zoom state. The tag [layername_check|select] outputs “checked” or “selected” when a named layer is on, which is useful for HTML forms. Layer metadata can be accessed with [layername_metadatakey] (the underscore is part of the syntax). Zoom widgets often use [zoom_N_select] for values -25..25 and [zoomdir_-1|0|1_check] for zoom direction persistence. If controls do not persist, verify the LAYER NAME matches the token used in the template and that the CGI parameters are being passed through unchanged.",
    "keywords": [
      "layer persistence",
      "layername_check",
      "checked/selected",
      "metadata access",
      "zoom_N_select",
      "zoomdir",
      "HTML forms",
      "LAYER NAME",
      "CGI passthrough",
      "state debugging"
    ]
  },
  {
    "id": 139,
    "text": "Query templates add shape and attribute substitutions. [shpext] returns the current shape extent plus a buffer; [shpidx] and [shpclass] expose feature and class indexes. [shpxy] can output coordinate lists with rich formatting options (separators, headers/footers, outer/inner ring wrappers) and supports centroid=true, buffer=, and precision=, which is useful for SVG or KML output. Attribute substitutions (often via item tags) support lc=true, commify=true, escape=(html/url/none), ignoremissing=true, nullformat=, and padding=. If attributes are blank, confirm the query layer is active and that field names match the data source exactly.",
    "keywords": [
      "query templates",
      "[shpext]",
      "[shpxy]",
      "centroid",
      "KML/SVG",
      "attribute options",
      "ignoremissing",
      "nullformat",
      "result counters",
      "field names"
    ]
  },
  {
    "id": 140,
    "text": "A minimal interactive template is usually a single HTML form whose action points to [program]. Inside, tags inject the generated map image ([img]), a reference image ([ref]), a legend ([legend]), and a scalebar ([scalebar]). Form controls use zoom persistence tags (e.g., [zoom_2_select]) and layer toggle tags to maintain state between requests. When the interface shows a blank image or resets, check that the template’s first line contains “mapservertemplate”, that the form action is correct, and that IMAGEPATH/IMAGEURL are configured so the generated images are reachable.",
    "keywords": [
      "template sample",
      "[program]",
      "[img]",
      "[ref]",
      "[legend]",
      "[scalebar]",
      "blank image",
      "state reset",
      "IMAGEPATH",
      "magic string"
    ]
  },
  {
    "id": 141,
    "text": "Run-time substitution can replace sensitive values like filenames and SQL fragments, so MapServer requires pattern validation (mandatory since 6.0). The recommended approach is a VALIDATION block (available in LAYER, CLASS, and WEB) that maps variable names to regular-expression patterns. Default values can be set using keys like default_year. If the same key exists in multiple VALIDATION blocks, the most specific wins (CLASS overrides LAYER overrides WEB). An older mechanism using METADATA keys like myvar_validation_pattern exists but is deprecated. For server hardening, also review environment variables such as MS_MAP_PATTERN or MS_MAP_NO_PATH that restrict mapfile access.",
    "keywords": [
      "Run-time Substitution",
      "VALIDATION",
      "regex pattern",
      "default_ keys",
      "precedence",
      "METADATA deprecated",
      "myvar_validation_pattern",
      "MS_MAP_PATTERN",
      "MS_MAP_NO_PATH",
      "security"
    ]
  },
  {
    "id": 142,
    "text": "You can test validation and runtime substitution without a web server by running mapserv with a crafted QUERY_STRING (for example, mapserv -nh \"QUERY_STRING=...\" > out.png). This is handy for reproducing “invalid substitution value” errors in a controlled way. A typical FILTER might use placeholders like %multimedia% and %nseats%, then enforce patterns such as '^yes|no$' or '^[0-9]{1,2}$' in a VALIDATION block. If a value that “looks right” is rejected, check your regex anchors (^ and $), confirm quoting inside FILTER, and ensure the variable names in the URL match those used in the mapfile.",
    "keywords": [
      "mapserv -nh",
      "QUERY_STRING",
      "FILTER",
      "%variable%",
      "invalid substitution",
      "regex anchors",
      "command-line testing",
      "quoting",
      "CGI debugging",
      "validation patterns"
    ]
  },
  {
    "id": 143,
    "text": "Runtime substitution also works inside CLASS EXPRESSION blocks, for example comparing a feature’s [year] attribute against %year%. Define a validation pattern for year (e.g., four digits) and optionally a default value with default_year. When expressions behave unexpectedly, verify whether the data source exposes the attribute as an integer or a string. Tools like ogrinfo can show the field type; then write numeric expressions like ([year]=%year%) or string expressions with quotes like (\"[year]\"=\"%year%\"). Many “no features matched” issues come from mismatched quoting or wrong field types.",
    "keywords": [
      "CLASS EXPRESSION",
      "%year%",
      "default_year",
      "ogrinfo",
      "field type",
      "integer vs string",
      "quoting",
      "no matches",
      "OGR/GDAL",
      "runtime substitution"
    ]
  },
  {
    "id": 144,
    "text": "A UNION layer lets MapServer draw features from multiple vector source layers as one logical layer. Configure the union layer with CONNECTIONTYPE UNION and set CONNECTION to a comma-separated list of source layer names. All layers involved (union and sources) must have the same TYPE (all POINT, all POLYGON, etc.). To avoid double rendering, keep the source layers STATUS OFF and the union layer STATUS DEFAULT/ON. If the union layer draws nothing, check for typos in the CONNECTION list, verify the source layers are valid on their own, and confirm TYPE consistency across all layers.",
    "keywords": [
      "union layer",
      "CONNECTIONTYPE UNION",
      "CONNECTION list",
      "source layers",
      "same TYPE",
      "STATUS OFF",
      "double rendering",
      "layer name typo",
      "MapServer 6.0",
      "vector only"
    ]
  },
  {
    "id": 145,
    "text": "Union layers can reference attributes from each source layer, but feature queries expose only two union metadata attributes by default: Union_SourceLayerName and Union_SourceLayerGroup. If your query output is missing expected fields, set a PROCESSING \"ITEMS=...\" option on the union layer to explicitly list which attributes should be provided. This also helps when sources have different schemas and you need a consistent attribute set. Debugging tip: run a query against each source layer first to confirm attribute names and types before relying on the union layer.",
    "keywords": [
      "Union_SourceLayerName",
      "Union_SourceLayerGroup",
      "PROCESSING ITEMS",
      "feature query",
      "attribute exposure",
      "schema differences",
      "selection operations",
      "consistent schema",
      "debugging",
      "query templates"
    ]
  },
  {
    "id": 146,
    "text": "Union layers support normal CLASS/STYLE symbology, and they also support STYLEITEM \"AUTO\" to draw features using styles provided by the source layers (when the driver supplies them). When using STYLEITEM AUTO, define an empty CLASS in the union layer so MapServer can fill it at runtime from the source layer styles. If AUTO styling produces blank output, confirm that the source data format actually carries style information, and test without AUTO by defining explicit classes. Errors often come from forgetting the empty CLASS block or expecting AUTO styles from a source that does not support them.",
    "keywords": [
      "STYLEITEM AUTO",
      "union styling",
      "inherit styles",
      "empty CLASS",
      "driver support",
      "AUTO styles",
      "blank output",
      "explicit classes",
      "runtime class",
      "debug"
    ]
  },
  {
    "id": 147,
    "text": "Union layers may combine sources in different projections, but reprojection adds cost and can shift features if SRS definitions are wrong. A typical configuration sets MAP and union layer PROJECTION to a target SRS, while a source layer keeps its native PROJECTION. MapServer reprojects that source into the union SRS (for example EPSG:4326 into EPSG:3978). If features appear offset, clipped, or trigger projection errors, verify each layer’s PROJECTION, confirm coordinates are valid for that SRS, and prefer a single shared projection when performance is critical.",
    "keywords": [
      "union reprojection",
      "MAP PROJECTION",
      "layer PROJECTION",
      "EPSG:4326",
      "EPSG:3978",
      "offset features",
      "clipping",
      "projection errors",
      "performance",
      "SRS consistency"
    ]
  },
  {
    "id": 148,
    "text": "The WEB object controls CGI output and where MapServer writes images. BROWSEFORMAT and QUERYFORMAT set MIME types (for example image/svg+xml). TEMPLATE defines the main interface template, while HEADER and FOOTER wrap multi-result query outputs. IMAGEPATH must be a writable directory for the web server user and typically must end with a slash. IMAGEURL must map IMAGEPATH to a browser-accessible URL prefix. Many “blank map”, “msSaveImage(): Unable to access file”, and “cannot open image” errors trace back to a non-writable IMAGEPATH or an IMAGEURL that doesn’t match the filesystem location.",
    "keywords": [
      "WEB",
      "BROWSEFORMAT",
      "QUERYFORMAT",
      "TEMPLATE",
      "HEADER",
      "FOOTER",
      "IMAGEPATH writable",
      "IMAGEURL mapping",
      "msSaveImage error",
      "blank map"
    ]
  },
  {
    "id": 149,
    "text": "WEB scale limits help prevent extreme zooms. MAXSCALEDENOM is the minimum scale allowed (prevents zooming too far out), while MINSCALEDENOM is the maximum scale allowed (prevents zooming too far in). When requests exceed these bounds, MapServer clamps the output scale and can optionally redirect to alternate templates using MAXTEMPLATE or MINTEMPLATE to support nested applications. The older MAXSCALE keyword was removed in MapServer 8.0, so leaving MAXSCALE in a mapfile can cause parse errors or unexpected behavior; use MAXSCALEDENOM instead.",
    "keywords": [
      "MAXSCALEDENOM",
      "MINSCALEDENOM",
      "scale limits",
      "MAXTEMPLATE",
      "MINTEMPLATE",
      "nested apps",
      "zoom clamp",
      "MAXSCALE removed",
      "MapServer 8.0",
      "parse error"
    ]
  },
  {
    "id": 150,
    "text": "WEB METADATA stores arbitrary name/value pairs and can also control CGI security and tile rendering. The ms_enable_modes key can disable CGI modes using patterns like “!*” (disable all) and then listing exceptions (e.g., allow MAP and LEGEND only). For mode=tile, tile_map_edge_buffer renders into a buffered frame and clips to reduce edge artifacts from wide lines or big symbols, while tile_metatile_level renders metatiles to reduce label repetition at higher cost. TEMPPATH sets the temp directory for many operations and can be overridden by the MS_TEMPPATH environment variable; misconfigured temp paths often cause file I/O errors.",
    "keywords": [
      "WEB METADATA",
      "ms_enable_modes",
      "CGI security",
      "mode=tile",
      "tile_map_edge_buffer",
      "tile_metatile_level",
      "label repetition",
      "TEMPPATH",
      "MS_TEMPPATH",
      "temp files"
    ]
  },
  {
    "id": 151,
    "text": "MapServer can load XML mapfiles by translating XML into the standard text mapfile format using XSLT. This requires building MapServer with XSLT/EXSLT support and setting the MS_XMLMAPFILE_XSLT environment variable to the XSLT stylesheet path used for conversion. When enabled, passing a .xml filename to the CGI map= parameter triggers automatic XML-to-text translation. This is useful for pipelines that generate mapfiles as XML, but it adds parsing and transformation overhead, so caching or pre-conversion may be needed for high-traffic services. If XML map loading fails, verify the environment variable is visible to the MapServer process.",
    "keywords": [
      "XML mapfile",
      "XSLT",
      "EXSLT",
      "MS_XMLMAPFILE_XSLT",
      "XML-to-text",
      "CGI map=",
      "build flags",
      "environment variable",
      "performance overhead",
      "conversion stylesheet"
    ]
  },
  {
    "id": 152,
    "text": "Basic mapfile rules explain many confusing errors. Mapfile keywords are case-insensitive, but attribute names inside [ATTRIBUTENAME] are case-sensitive and must match the data source schema (shapefile DBF fields are often uppercase; PostGIS fields are often lowercase). MapServer reads the file top-to-bottom, so layer order controls draw order. Strings containing non-alphanumeric characters or MapServer keywords should be quoted (double-quotes recommended). Since 7.0, mapfiles are expected to be UTF-8 encoded. Comments can use #, and since 7.2 MapServer also supports C-style /* ... */ comments. Many parse errors come from unbalanced quotes or missing END statements.",
    "keywords": [
      "mapfile syntax",
      "case-insensitive keywords",
      "attribute case-sensitive",
      "draw order",
      "quoting strings",
      "UTF-8",
      "comments",
      "missing END",
      "unbalanced quotes",
      "common errors"
    ]
  },
  {
    "id": 153,
    "text": "Regular expressions in MapServer use the operating system’s C library (POSIX-style), so subtle differences can appear across platforms. Regexes are used in VALIDATION patterns, FILTER expressions, and some CLASS expressions, so portability matters when moving a mapfile between Linux and Windows. If a pattern works on one server but fails on another, test it against the target platform’s regex engine and simplify where possible. For troubleshooting, editor syntax highlighting for .map files can help you spot missing END blocks, mismatched quotes, and misplaced directives before MapServer’s parser reports a generic error.",
    "keywords": [
      "POSIX regex",
      "C library regex",
      "platform differences",
      "VALIDATION regex",
      "FILTER",
      "CLASS expression",
      "Linux vs Windows",
      "syntax highlighting",
      "debugging",
      "generic parse error"
    ]
  },
  {
    "id": 154,
    "text": "Chapter 8 (Data Input) starts by framing vector data as coordinates representing points, lines, and polygons, with resolution-independent rendering. In MapServer troubleshooting, it helps to separate “data problems” (bad geometries, missing indexes, wrong SRS) from “mapfile problems” (wrong CONNECTION/DATA syntax, wrong TYPE, scale limits, permissions). This chapter is organized as a practical format guide: each format section typically shows a file listing, how to inspect the datasource using ogrinfo, then an example LAYER block you can paste into a mapfile. When a layer draws blank, reproduce the same datasource inspection steps outside MapServer first.",
    "keywords": [
      "Data Input",
      "vector data",
      "points lines polygons",
      "resolution independent",
      "datasource troubleshooting",
      "ogrinfo workflow",
      "LAYER examples",
      "blank layer debug",
      "format guide"
    ]
  },
  {
    "id": 155,
    "text": "MapServer and OGR use the same mental model: a **data source** contains one or more **layers**. Formats are grouped as file-based (single files like SHP/DGN/GeoJSON), directory-based (folders like ArcInfo coverages), and database connections (PostGIS, file geodatabases, etc.). Many mistakes come from confusing the datasource with the layer name: your CONNECTION often points to the datasource (file/folder/DB), while DATA identifies the specific layer/table inside it. If ogrinfo lists multiple layers but MapServer draws nothing, verify that DATA matches the exact layername shown by ogrinfo and that your LAYER TYPE matches the geometry type.",
    "keywords": [
      "data source vs layer",
      "OGR model",
      "file-based formats",
      "directory-based formats",
      "database connections",
      "CONNECTION vs DATA",
      "ogrinfo layername",
      "LAYER TYPE",
      "geometry type mismatch"
    ]
  },
  {
    "id": 156,
    "text": "Database-style datasources share common connection requirements: host/service, database name, and credentials, plus a target table/view and the geometry column. A frequent error pattern is “connection succeeds but nothing draws” because MapServer is reading the wrong table, the geometry column name is wrong, or the geometry has an unknown/incorrect SRS. Start with ogrinfo to confirm the layer/table exists, geometry type is what you expect, and extents look sane. If extents are huge or near zero, suspect unit/SRS problems. If performance is poor, add spatial/attribute indexes (where supported) and consider providing an explicit EXTENT in the mapfile.",
    "keywords": [
      "database connection",
      "geometry column",
      "table view name",
      "SRS mismatch",
      "ogrinfo inspect",
      "extent sanity check",
      "spatial index",
      "attribute index",
      "performance tuning"
    ]
  },
  {
    "id": 157,
    "text": "ArcInfo Coverages are directory-based datasets composed of many ADF files inside a folder (the folder name is the coverage). Access is typically via OGR: set CONNECTIONTYPE OGR, point CONNECTION to the coverage folder, and set DATA to the specific coverage layer name (as shown by ogrinfo, e.g., PAL). If MapServer can’t open the datasource, check filesystem permissions on the whole directory and confirm you didn’t accidentally point CONNECTION to an individual .adf file. If features appear clipped or missing, verify the coverage’s extent and projection; many coverage examples report unknown SRS, so you may need to define PROJECTION in the LAYER or MAP.",
    "keywords": [
      "ArcInfo Coverage",
      "ADF files",
      "directory datasource",
      "CONNECTIONTYPE OGR",
      "DATA PAL",
      "unknown SRS",
      "permissions",
      "coverage extent",
      "projection troubleshooting"
    ]
  },
  {
    "id": 158,
    "text": "ArcSDE is a special case: MapServer’s **native SDE driver was removed** (MapServer 7.0 era), and GDAL’s ArcSDE support was also removed in later GDAL releases. If you inherit an ArcSDE-based mapfile, common symptoms include compile-time driver absence, runtime “unsupported connectiontype,” or empty layers with no clear errors. The practical fix is usually migration: export to a supported format (often PostGIS, GeoPackage, or Shapefile/FlatGeobuf) and update the LAYER CONNECTIONTYPE and DATA accordingly. When debugging old configs, first confirm what drivers your deployment actually supports (ogrinfo --formats and MapServer build info).",
    "keywords": [
      "ArcSDE removed",
      "native driver removal",
      "GDAL ArcSDE removed",
      "unsupported connectiontype",
      "migration strategy",
      "driver availability",
      "ogrinfo --formats",
      "legacy mapfile",
      "empty layer"
    ]
  },
  {
    "id": 159,
    "text": "Legacy ArcSDE examples emphasize that CONNECTION string order and service parameters matter (server name/IP, port/service, instance/database, user/password). Query features may require TEMPLATE for attribute access; adding TEMPLATE when you only need drawing can slow queries. PROCESSING options can help when the driver mis-detects the unique id column (OBJECTID override) or when you want special query ordering (QUERYORDER=ATTRIBUTE) in niche cases. If filters behave strangely, verify quoting in FILTER and confirm the attribute names and table qualifiers are exact. For any SDE-like workflow, log at DEBUG 3 with MS_ERRORFILE so you can see the final query behavior and connection failures.",
    "keywords": [
      "ArcSDE CONNECTION string",
      "service port",
      "OBJECTID override",
      "QUERYORDER=ATTRIBUTE",
      "TEMPLATE for queries",
      "FILTER quoting",
      "qualified column names",
      "DEBUG 3 logging",
      "MS_ERRORFILE"
    ]
  },
  {
    "id": 160,
    "text": "CONNECTIONTYPE CONTOUR lets MapServer generate vector contour lines from a raster elevation band. The key setup is: set LAYER TYPE LINE, set DATA to a raster file (or TILEINDEX for multiple rasters), and use PROCESSING \"BANDS=n\" to choose the elevation band. Then configure contour generation with PROCESSING keys like CONTOUR_ITEM (attribute name for elevation values), CONTOUR_INTERVAL (regular interval), or CONTOUR_LEVELS (explicit level list). If no contours appear, verify the raster band actually contains elevation values, and confirm your scale-dependent intervals aren’t excluding the current request scale. Start with a single simple interval before adding complex scale rules.",
    "keywords": [
      "CONNECTIONTYPE CONTOUR",
      "raster to contours",
      "TYPE LINE",
      "PROCESSING BANDS",
      "CONTOUR_ITEM",
      "CONTOUR_INTERVAL",
      "CONTOUR_LEVELS",
      "tileindex rasters",
      "missing contours"
    ]
  },
  {
    "id": 161,
    "text": "Contour layers support advanced tuning: scale-dependent CONTOUR_INTERVAL/CONTOUR_LEVELS rules can change spacing as users zoom, and MapServer 7.0.1+ can combine TILEINDEX + WMSTime to pick the correct raster from a tileindex. Contour output can be overly dense because GDAL’s contour algorithm generates many vertices; you can simplify lines using GEOMTRANSFORM expressions, for example generalizing by a fraction of [data_cellsize] (the raster cell size for the fetched extent). If contours look jagged or heavy, simplify; if they look offset, re-check raster SRS and MAP/LAYER PROJECTION. Always test with map2img to isolate raster access vs CGI templating issues.",
    "keywords": [
      "scale-dependent intervals",
      "WMSTime tileindex",
      "dense contour vertices",
      "GEOMTRANSFORM simplify",
      "data_cellsize",
      "generalize tolerance",
      "projection alignment",
      "map2img test",
      "contour performance"
    ]
  },
  {
    "id": 162,
    "text": "Microstation DGN is accessed through OGR. The datasource is a single .dgn file, but all features are typically exposed in one OGR layer named “elements,” and MapServer’s LAYER TYPE (POINT/LINE/POLYGON) controls what geometry you read. DGNs may carry internal styling; STYLEITEM \"AUTO\" can use those styles, but a common pitfall is that many DGN features are white and disappear on a white map background—set a contrasting background or explicit STYLE colors. If units look wrong (meters vs feet/kilometers), ogrinfo may not make it obvious; sometimes you need to verify in Microstation tooling or by checking known distances against extents.",
    "keywords": [
      "DGN",
      "OGR elements layer",
      "STYLEITEM AUTO",
      "white on white",
      "TYPE POINT LINE POLYGON",
      "unit problems",
      "extent sanity",
      "DGN styling",
      "ogrinfo DGN"
    ]
  },
  {
    "id": 163,
    "text": "ESRI File Geodatabases (.gdb folders) are accessed through OGR. A frequent failure mode is missing driver support: only geodatabases created by newer ArcGIS versions may be readable depending on the driver (FileGDB vs OpenFileGDB). Use ogrinfo on the .gdb directory to list tables, then run ogrinfo -summary on the specific table to confirm geometry type and extents. In a mapfile, set CONNECTIONTYPE OGR, set CONNECTION to the .gdb folder, and set DATA to the table/layer name from ogrinfo. If performance is poor, add explicit EXTENT and consider CLOSE_CONNECTION=DEFER to reduce connection overhead in multi-layer maps.",
    "keywords": [
      "FileGDB",
      "OpenFileGDB",
      "OGR .gdb directory",
      "driver availability",
      "ogrinfo -summary",
      "CONNECTIONTYPE OGR",
      "DATA table name",
      "EXTENT optimization",
      "CLOSE_CONNECTION=DEFER"
    ]
  },
  {
    "id": 164,
    "text": "ESRI Personal Geodatabases are Microsoft Access .mdb files, accessed via OGR’s PGeo driver. You can connect directly to the .mdb or via an ODBC DSN, and ogrinfo should list available tables. In MapServer, set CONNECTIONTYPE OGR and use CONNECTION \"test.mdb\" for direct access or CONNECTION \"PGeo:testDSN\" for ODBC, with DATA set to the table name. Common issues include missing PGeo/ODBC support on non-Windows builds, permissions on the .mdb file, or geometry columns that show as “Unknown” types. For debugging, first confirm ogrinfo opens the datasource successfully and reports a sane extent, then copy that exact layername into DATA.",
    "keywords": [
      "Personal Geodatabase",
      "MDB",
      "PGeo driver",
      "ODBC DSN",
      "CONNECTION PGeo:testDSN",
      "DATA table name",
      "driver support",
      "permissions",
      "unknown geometry"
    ]
  },
  {
    "id": 165,
    "text": "Shapefiles are usually best accessed natively (without OGR) and consist of at least .shp, .shx, and .dbf with the same basename. In mapfiles, the shapefile path is typically relative to SHAPEPATH, and DATA points to the shapefile basename (or full path). If you use OGR to inspect a directory of shapefiles, ogrinfo lists each shapefile as a separate layer; don’t confuse that listing with native access. Common “can’t open shapefile” issues are missing .shx, wrong case on filenames (Linux), or wrong SHAPEPATH. If the layer draws slowly, ensure indexes exist and consider setting a correct EXTENT to avoid expensive scans.",
    "keywords": [
      "Shapefile",
      "SHP SHX DBF",
      "native access",
      "SHAPEPATH",
      "DATA basename",
      "missing .shx",
      "case sensitivity",
      "ogrinfo directory",
      "extent performance"
    ]
  },
  {
    "id": 166,
    "text": "When a shapefile layer draws blank, validate the dataset before blaming symbology: run ogrinfo -summary to confirm the geometry type (Point/LineString/Polygon), feature count, and extent. If the extent is wildly different from your MAP EXTENT, features can be off-screen rather than missing. Also watch for projection mismatches: shapefiles rely on an external .prj; if it’s missing or wrong, MapServer may still draw but in the wrong place. If labels show garbled characters, the issue is often datasource encoding; set LAYER ENCODING when needed and ensure ICONV support exists in the build.",
    "keywords": [
      "blank shapefile",
      "ogrinfo -summary",
      "feature count",
      "extent mismatch",
      "projection mismatch",
      ".prj file",
      "off-screen features",
      "LAYER ENCODING",
      "ICONV"
    ]
  },
  {
    "id": 167,
    "text": "FlatGeobuf is a single-file binary vector format optimized for read/query speed using a packed Hilbert R-Tree index, enabling fast bounding-box filtering. It’s often used as a modern alternative to shapefiles when you want great performance with a simple file deployment model. You’ll typically see a .fgb extension, and you can create one from other datasources using ogr2ogr (for example exporting a table from a SpatiaLite/SQLite database). If performance is unexpectedly poor, suspect that you are not using FlatGeobuf native access, the index is missing/corrupt, or MapServer is repeatedly reopening the file due to connection settings.",
    "keywords": [
      "FlatGeobuf",
      ".fgb",
      "Hilbert R-Tree",
      "fast bbox filter",
      "ogr2ogr export",
      "single-file vectors",
      "performance format",
      "native access",
      "index troubleshooting"
    ]
  },
  {
    "id": 168,
    "text": "FlatGeobuf can be used via **native direct access** or via **OGR**. For OGR, you typically need GDAL 3.1+ and must include the .fgb filename in CONNECTION; DATA should be the internal layer name (from ogrinfo). Performance tuning includes CONNECTIONOPTIONS such as VERIFY_BUFFERS=NO (skips buffer validity checks) and PROCESSING \"CLOSE_CONNECTION=DEFER\" to avoid reopen overhead. For maximum speed, provide an explicit EXTENT and keep symbology simple while you validate data access. If MapServer draws nothing, double-check that DATA matches the layer name exactly and that your build actually includes FlatGeobuf support (ogrinfo --formats).",
    "keywords": [
      "FlatGeobuf OGR driver",
      "GDAL 3.1+",
      "CONNECTION .fgb",
      "DATA layername",
      "CONNECTIONOPTIONS VERIFY_BUFFERS",
      "CLOSE_CONNECTION=DEFER",
      "EXTENT for performance",
      "driver support",
      "blank output debug"
    ]
  },
  {
    "id": 169,
    "text": "For services, you can configure WFS/WMS output as FlatGeobuf using an OUTPUTFORMAT with DRIVER \"OGR/FlatGeoBuf\" and FORMATOPTION settings such as STORAGE=filesystem and a target FILENAME. Then advertise it with LAYER METADATA (e.g., wfs_getfeature_formatlist including OGRFLATGEOBUF) so it appears in GetCapabilities. A common debugging workflow is: request GetCapabilities, confirm the output format is listed, then request GetFeature with OUTPUTFORMAT=OGRFLATGEOBUF and verify you receive a .fgb payload. If you get XML instead, your output format wasn’t selected or metadata keys are missing/typoed.",
    "keywords": [
      "OUTPUTFORMAT",
      "OGR/FlatGeoBuf",
      "FORMATOPTION STORAGE",
      "wfs_getfeature_formatlist",
      "GetCapabilities check",
      "GetFeature OUTPUTFORMAT",
      "WFS result formats",
      "metadata typos",
      "service debugging"
    ]
  },
  {
    "id": 170,
    "text": "GML (Geographic Markup Language) is an OGC XML format for vector and attributes. In practice, you read GML via OGR: set CONNECTIONTYPE OGR, set CONNECTION to the .gml/.xml file, and set DATA to the layer name reported by ogrinfo. GML files can be large and parsing can be slow, so performance problems are often “format cost,” not mapfile mistakes—test with ogrinfo first to measure read time. If geometry type shows as Unknown or extents are missing, the GML schema may be incomplete or inconsistent. In those cases, converting to a faster format (GeoPackage/FlatGeobuf) is often the most reliable fix.",
    "keywords": [
      "GML",
      "OGC XML",
      "CONNECTIONTYPE OGR",
      "ogrinfo layername",
      "slow parsing",
      "schema issues",
      "unknown geometry",
      "convert to GeoPackage",
      "convert to FlatGeobuf"
    ]
  },
  {
    "id": 171,
    "text": "GeoJSON access in MapServer is provided through OGR’s GeoJSON driver, so a typical LAYER uses CONNECTIONTYPE OGR, a CONNECTION that includes the .json filename, and DATA set to the GeoJSON layer name. Use ogrinfo on the .json file to confirm geometry type, feature count, and extent; many GeoJSON datasets are in WGS84 (EPSG:4326), so projection mismatches can hide features off-screen. If GeoJSON fields appear nested or awkward, consider OGR open options (via CONNECTIONOPTIONS) in newer MapServer versions. For Windows workflows, converting from a demo SpatiaLite/SQLite database using ogr2ogr is a common way to create sample GeoJSON for testing.",
    "keywords": [
      "GeoJSON",
      "OGR GeoJSON driver",
      "CONNECTION .json",
      "DATA layername",
      "ogrinfo GeoJSON",
      "EPSG:4326",
      "nested attributes",
      "CONNECTIONOPTIONS",
      "ogr2ogr convert"
    ]
  },
  {
    "id": 172,
    "text": "A practical GeoJSON debugging loop is: (1) inspect with ogrinfo, (2) create a minimal LAYER with TYPE matching the GeoJSON geometry, (3) set an explicit EXTENT for speed and to avoid auto-extent surprises, and (4) test with map2img rather than CGI templates. For OGR datasources, PROCESSING \"CLOSE_CONNECTION=DEFER\" can reduce repeated open/close overhead. If the layer draws but is slow, suspect missing spatial indexing (GeoJSON has none) or overly complex styling; convert heavy GeoJSON to GeoPackage or FlatGeobuf for production. If the layer fails to open, confirm the GeoJSON driver exists in your GDAL build (ogrinfo --formats).",
    "keywords": [
      "GeoJSON troubleshooting",
      "minimal LAYER test",
      "EXTENT hint",
      "map2img",
      "CLOSE_CONNECTION=DEFER",
      "no spatial index",
      "convert for production",
      "driver exists",
      "slow GeoJSON"
    ]
  },
  {
    "id": 173,
    "text": "GeoPackage (GPKG) is an SQLite-based container that can hold multiple vector layers and indexes. MapServer typically reads it via OGR, so you need both the “GPKG” driver and the “SQLite/SpatiaLite” driver available in your GDAL/OGR build (check with ogrinfo --formats). MapServer releases prior to certain 7.4.x fixes had known GPKG issues, so using a modern MapServer version improves reliability. In a mapfile, use CONNECTIONTYPE OGR, CONNECTION pointing to the .gpkg file, and DATA set to the table/layer name. If MapServer opens the file but queries are painfully slow, suspect missing spatial indexes.",
    "keywords": [
      "GeoPackage",
      "GPKG",
      "SQLite container",
      "OGR GPKG driver",
      "SpatiaLite driver",
      "ogrinfo --formats",
      "DATA table name",
      "MapServer version issues",
      "slow queries"
    ]
  },
  {
    "id": 174,
    "text": "GeoPackage performance depends heavily on indexes. You can use ogrinfo with SQL helpers like HasSpatialIndex() to confirm whether a table’s geometry has a spatial index, and CreateSpatialIndex() to add one when missing. If MapServer filters or queries on a specific attribute, adding an attribute index for that column can also matter (CREATE INDEX). Typical symptoms of missing indexes are long draw times even for small extents and slow attribute queries. If you see timeouts, add the spatial index first, then retest with map2img and DEBUG logging. Always validate that you are indexing the correct table and geometry column name.",
    "keywords": [
      "GeoPackage spatial index",
      "HasSpatialIndex",
      "CreateSpatialIndex",
      "attribute index",
      "CREATE INDEX",
      "slow draws",
      "query timeouts",
      "geometry column name",
      "map2img retest"
    ]
  },
  {
    "id": 175,
    "text": "A solid GeoPackage LAYER pattern is: set CONNECTIONTYPE OGR, CONNECTION \"countries.gpkg\", DATA \"countries\" (exact OGR layername), and provide an explicit EXTENT “for maximum performance.” Adding PROCESSING \"CLOSE_CONNECTION=DEFER\" reduces reopen overhead across requests. Start with a simple CLASS/STYLE to confirm rendering works, then add labeling and filters. If you get “unable to open datasource,” confirm file permissions and that the .gpkg path is correct. If data draws but is clipped, re-check that EXTENT and PROJECTION match the dataset’s coordinate system.",
    "keywords": [
      "GeoPackage LAYER example",
      "CONNECTIONTYPE OGR",
      "CONNECTION .gpkg",
      "DATA layername",
      "EXTENT for performance",
      "CLOSE_CONNECTION=DEFER",
      "permissions",
      "clipping issues",
      "SRS consistency"
    ]
  },
  {
    "id": 176,
    "text": "map2img is the fastest way to validate that a mapfile can draw without inexampleng CGI templates, web paths, or client parameters. Run map2img with a debug level (e.g., -map_debug 3) and read the timing breakdown: msDrawMap() setup time, per-layer draw time, label cache time, and msSaveImage time. If a map draws blank in CGI but works in map2img, your problem is usually WEB IMAGEPATH/IMAGEURL or template logic, not the datasource. If map2img fails too, the console output and MS_ERRORFILE logs give a direct pointer to connection failures, missing drivers, or parse errors.",
    "keywords": [
      "map2img",
      "debug timing",
      "msDrawMap per-layer",
      "label cache",
      "msSaveImage",
      "CGI vs CLI isolate",
      "WEB IMAGEPATH",
      "MS_ERRORFILE logs",
      "parse errors"
    ]
  },
  {
    "id": 177,
    "text": "GPX (GPS Exchange Format) is a lightweight XML format for GPS waypoints, routes, and tracks, accessed through OGR. A single .gpx file may expose multiple OGR layers/feature types (for example waypoints, tracks, track_points). In MapServer, use CONNECTIONTYPE OGR with CONNECTION pointing to the .gpx file, then set DATA to the specific feature type layer. Make sure LAYER TYPE matches the feature type: waypoints are usually POINT, tracks are usually LINE. If nothing draws, confirm the GPX driver exists (ogrinfo --formats), confirm DATA matches the listed layer name, and check extents to ensure features are in the current map view.",
    "keywords": [
      "GPX",
      "OGR GPX driver",
      "waypoints routes tracks",
      "DATA feature type",
      "TYPE POINT",
      "TYPE LINE",
      "ogrinfo --formats",
      "extent check",
      "blank GPX layer"
    ]
  },
  {
    "id": 178,
    "text": "MapServer can also embed small datasets directly in a mapfile using inline FEATURE blocks. For a POINT layer, you define FEATURE, set a POINT, and style it; for LINE/POLYGON you provide a POINTS list. Coordinates must be in the units of the layer’s projection (e.g., decimal degrees if your map projection is geographic). Inline features are great for debugging symbolization or illustrating a few reference markers, but they can be a source of parse errors if END tokens are missing or POINTS are not closed correctly. If an inline layer renders in the wrong place, verify the map projection and coordinate order.",
    "keywords": [
      "inline FEATURE",
      "POINTS list",
      "TYPE POINT",
      "TYPE LINE",
      "TYPE POLYGON",
      "projection units",
      "decimal degrees",
      "missing END",
      "parse error"
    ]
  },
  {
    "id": 179,
    "text": "KML is read through OGR; before writing mapfile config, verify your GDAL/OGR build includes the KML driver (ogrinfo --formats). In MapServer, set CONNECTIONTYPE OGR, set CONNECTION to the .kml file, and set DATA to the layer name reported by ogrinfo. If the KML driver is missing, MapServer will fail to open the datasource even if your mapfile syntax is correct. KML datasets often assume WGS84, so projection mismatches can hide features. Start with a simple style, confirm the layer draws, then add labels and filters. If performance is slow, consider converting KML to GeoPackage or FlatGeobuf for production workflows.",
    "keywords": [
      "KML",
      "OGR KML driver",
      "ogrinfo --formats",
      "CONNECTIONTYPE OGR",
      "DATA layername",
      "WGS84 assumption",
      "projection mismatch",
      "convert to GeoPackage",
      "convert to FlatGeobuf"
    ]
  },
  {
    "id": 180,
    "text": "KML “Superoverlay” datasets can be drawn as rasters through GDAL by pointing a raster LAYER’s DATA to a KML URL or file. A common pattern is DATA \"/vsicurl/http://…/mv-doqq.kml\" so GDAL can stream the referenced tiles. Test the setup with map2img and a high debug level: msDrawRasterLayerGDAL() lines confirm that GDAL opened the KML, selected bands, and computed source/destination windows. If the layer draws blank, check that your GDAL build has KML support, the URL is reachable from the server, and that MapServer can write the output image format you requested.",
    "keywords": [
      "KML",
      "Superoverlay",
      "GDAL",
      "RASTER layer",
      "DATA",
      "vsicurl",
      "map2img",
      "msDrawRasterLayerGDAL",
      "debug output",
      "tile streaming"
    ]
  },
  {
    "id": 181,
    "text": "MapServer can read Microsoft SQL Server spatial tables either via GDAL/OGR (CONNECTIONTYPE OGR using the MSSQLSpatial driver) or via a dedicated MapServer driver compiled as a plugin (msplugin_mssql2008.dll). The OGR route is usually simplest for quick validation, while the plugin route provides native SQL select syntax in the DATA clause and controlled loading through a MapServer CONFIG file. When debugging, separate “can GDAL/OGR open the database?” from “does my mapfile DATA/geometry column match the table schema?”. Most MSSQL issues come down to missing driver support, incorrect connection strings, or mismatched geometry column names.",
    "keywords": [
      "MSSQL",
      "SQL Server",
      "MSSQLSpatial",
      "CONNECTIONTYPE OGR",
      "CONNECTIONTYPE PLUGIN",
      "msplugin_mssql2008.dll",
      "MapServer CONFIG",
      "spatial tables",
      "geometry",
      "geography"
    ]
  },
  {
    "id": 182,
    "text": "You can populate MSSQL spatial tables with ogr2ogr using the MSSQLSpatial driver, e.g. ogr2ogr -f MSSQLSpatial … province.shp. MapServer/OGR connections use a single connection string with server, database, and authentication (trusted_connection or uid/pwd). If you omit an explicit ODBC Driver, the legacy “SQL Server” driver may be chosen, so specifying a modern driver such as “ODBC Driver 17 for SQL Server” can avoid connection issues on newer systems. Always validate the credentials and network access with ogrinfo/ogr2ogr before troubleshooting mapfile syntax.",
    "keywords": [
      "ogr2ogr",
      "MSSQLSpatial",
      "ogrinfo",
      "ODBC Driver 17",
      "trusted_connection",
      "connection string",
      "server",
      "database",
      "upload shapefile",
      "authentication"
    ]
  },
  {
    "id": 183,
    "text": "For MSSQL via OGR, first confirm your GDAL build lists “MSSQLSpatial” in ogrinfo --formats, then test a connection with ogrinfo \"MSSQL:server=…;database=…;…\" <layer> -summary. In the mapfile, set CONNECTIONTYPE OGR and put the table and geometry column in the CONNECTION using tables=table_name(geomcol). You typically omit DATA unless providing a WHERE-based SQL filter. The usual PostGIS-style “using unique” and “using srid” tokens are not needed here because OGR reads metadata from MSSQL system tables.",
    "keywords": [
      "MSSQLSpatial",
      "ogrinfo --formats",
      "CONNECTIONTYPE OGR",
      "tables=…(geom)",
      "geometry column",
      "SQL WHERE",
      "GDAL",
      "metadata tables",
      "connection test",
      "layer summary"
    ]
  },
  {
    "id": 184,
    "text": "For MSSQL via the MapServer plugin, reference the DLL in the MapServer CONFIG file under a PLUGINS block, then use CONNECTIONTYPE PLUGIN and PLUGIN \"mssql\" inside the LAYER. The DATA string acts like a SQL select: \"geomcol from rivers USING UNIQUE idcol USING SRID=4326\". Queries can fail silently if SRID is wrong (search shapes don’t match), so set SRID correctly. If the geometry column is the SQL Server “geography” type, declare it explicitly as geomcol(geography) in DATA; otherwise the driver assumes “geometry”.",
    "keywords": [
      "MSSQL plugin",
      "PLUGINS",
      "CONNECTIONTYPE PLUGIN",
      "PLUGIN mssql",
      "DATA geom from table",
      "USING UNIQUE",
      "USING SRID",
      "geometry vs geography",
      "CONFIG file",
      "query failures"
    ]
  },
  {
    "id": 185,
    "text": "MSSQL performance and stability depend on indexes and driver options. Create a spatial index on the geometry column (for example via ogrinfo -sql \"create spatial index on rivers\" …) and, if the optimizer does not pick it, force it with an index hint in the DATA clause (using index …). Two useful PROCESSING options are CLOSE_CONNECTION=DEFER (connection pooling within a map draw) and MSSQL_READ_WKB=TRUE (fetch geometries as WKB). On Windows, plugin load failures often trace to DLL search order and PATH, so keep required client DLLs discoverable.",
    "keywords": [
      "spatial index",
      "index hint",
      "PROCESSING",
      "CLOSE_CONNECTION=DEFER",
      "MSSQL_READ_WKB",
      "WKB",
      "ogrinfo -sql",
      "query optimizer",
      "DLL search order",
      "performance tuning"
    ]
  },
  {
    "id": 186,
    "text": "NTF (National Transfer Format) files from the UK Ordnance Survey are accessed through OGR’s “UK .NTF” driver. MapServer uses CONNECTIONTYPE OGR, with CONNECTION pointing to the .ntf file (relative to SHAPEPATH or absolute) and DATA naming the target layer inside the file (e.g., LANDLINE_LINE). ogrinfo is the fastest way to list layers and confirm geometry types; expect a read-only warning (“NTF Driver doesn’t support update”), which is normal. If MapServer errors on incompatible geometry types, verify the selected DATA layer and the LAYER TYPE (POINT/LINE/POLYGON).",
    "keywords": [
      "NTF",
      "UK .NTF driver",
      "Ordnance Survey",
      "CONNECTIONTYPE OGR",
      ".ntf",
      "ogrinfo",
      "LANDLINE_LINE",
      "SHAPEPATH",
      "read-only",
      "geometry type mismatch"
    ]
  },
  {
    "id": 187,
    "text": "OGR support lets MapServer read many vector formats in their native form (MapInfo TAB, KML, GPX, TIGER/Line, etc.) through GDAL/OGR. To build it yourself, compile/install GDAL first and then build MapServer with -DWITH_OGR=ON. Starting with MapServer 7.0, OGR-driven 2.5D geometries can be handled when built with -DWITH_POINT_Z_M=ON; WFS output of Z/M often requires explicit layer metadata. When troubleshooting “driver not found” errors, the root cause is frequently that a needed OGR driver was not enabled in the GDAL build used by MapServer.",
    "keywords": [
      "OGR",
      "GDAL",
      "WITH_OGR",
      "vector formats",
      "MapInfo TAB",
      "TIGER/Line",
      "2.5D",
      "WITH_POINT_Z_M",
      "WFS metadata",
      "driver not found"
    ]
  },
  {
    "id": 188,
    "text": "An OGR layer in a mapfile expands the usual DATA into three pieces: CONNECTIONTYPE OGR, CONNECTION (the datasource), and DATA (the layer definition). CONNECTION is a file path, directory path, or a virtual service string; relative paths are resolved via SHAPEPATH first and then the mapfile location. DATA can be a layer name, a zero-based layer number, omitted (defaults to layer 0), or an SQL SELECT statement supported by the driver. If MapServer cannot open the datasource, check path resolution and permissions first; if it opens but renders nothing, validate the DATA layer name/number with ogrinfo.",
    "keywords": [
      "mapfile syntax",
      "CONNECTIONTYPE OGR",
      "CONNECTION",
      "DATA",
      "SHAPEPATH",
      "layer name",
      "layer number",
      "SQL SELECT",
      "datasource",
      "path permissions"
    ]
  },
  {
    "id": 189,
    "text": "OGR mapfile examples highlight driver-specific syntax. A Microstation DGN datasource often uses DATA \"0\" to pick the first layer, and STYLEITEM \"AUTO\" to reuse source styling. TIGER/Line uses a directory as CONNECTION (e.g., TGR25001) and DATA names a layer like CompleteChain. For multiple shapefiles in a directory, you can use a SQL JOIN in DATA to combine attributes in-database-like. Some modern OGR backends (e.g., ElasticSearch) use a service connection string (CONNECTION \"ES:\") plus CONNECTIONOPTIONS to forward HTTP auth headers from the web server environment.",
    "keywords": [
      "DGN",
      "TIGER/Line",
      "CompleteChain",
      "DATA 0",
      "STYLEITEM AUTO",
      "SQL JOIN",
      "directory datasource",
      "ElasticSearch",
      "CONNECTIONOPTIONS",
      "Authorization header"
    ]
  },
  {
    "id": 190,
    "text": "The ogrinfo utility is your primary debugger for OGR datasources. Use ogrinfo datasource_name to list layers, and ogrinfo datasource layer -summary (or without -summary) to inspect geometry type, feature count, extent, SRS WKT, and field definitions. Options include -ro for read-only (useful when the driver prints update warnings) and -q for quiet output. For directory datasources like TIGER, ogrinfo shows all contained layers. When STYLEITEM \"AUTO\" behaves unexpectedly, the per-feature “Style” string in ogrinfo output helps confirm what symbols and colors OGR is returning to MapServer.",
    "keywords": [
      "ogrinfo",
      "-ro",
      "-q",
      "layer list",
      "SRS WKT",
      "extent",
      "feature count",
      "field schema",
      "TIGER directory",
      "FeatureStyle"
    ]
  },
  {
    "id": 191,
    "text": "OGR layers can use tile indexes similarly to shapefile layers, but the TILEINDEX value is itself an OGR connection string (any supported OGR format, including a shapefile). Set CONNECTIONTYPE OGR, add TILEINDEX \"tiles.shp,0\" (optionally including a layer selector), and omit CONNECTION because it will be ignored. TILEITEM names the attribute holding each tile’s datasource location; if you don’t set it, the default is “location”. Build tileindex datasets with the ogrtindex utility or in a GIS. If tiles fail to load, inspect the location field values and confirm they are valid OGR connection strings from the MapServer runtime environment.",
    "keywords": [
      "TILEINDEX",
      "TILEITEM",
      "ogrtindex",
      "CONNECTION ignored",
      "OGR tileindex",
      "location field",
      "tiles.shp",
      "layer selector",
      "per-tile path",
      "random access"
    ]
  },
  {
    "id": 192,
    "text": "For expensive OGR datasources, you can reduce overhead with connection pooling. Add PROCESSING \"CLOSE_CONNECTION=DEFER\" on earlier layers using the same CONNECTION so MapServer keeps the dataset open until the last layer finishes; set CLOSE_CONNECTION=NORMAL on the final layer (or omit it) to close normally. The CONNECTION text must match exactly between layers for reuse. This is helpful for datasets that are slow to open or parse, but can increase memory usage, and if every layer defers closing the connection may remain open until MapServer exits (which is usually fine for CGI/MapScript but should be monitored).",
    "keywords": [
      "connection pooling",
      "CLOSE_CONNECTION=DEFER",
      "CLOSE_CONNECTION=NORMAL",
      "PROCESSING",
      "OGR datasource",
      "identical CONNECTION",
      "memory usage",
      "layer ordering",
      "S-57 example",
      "performance"
    ]
  },
  {
    "id": 193,
    "text": "STYLEITEM \"AUTO\" tells MapServer to render features using style information embedded in the OGR datasource (OGR FeatureStyle strings). To enable it, set STYLEITEM \"AUTO\" and include at least one CLASS (it may be empty); optionally add CLASSITEM if your classes use expressions. MapServer will populate styles dynamically per feature at runtime. Important limitations: MapServer still requires a fixed LAYER TYPE, so mixed-geometry OGR layers can trigger “incompatible geometry type” errors; and label caching is disabled for STYLEITEM AUTO layers. For MapInfo, OGR often returns symbol names like mapinfo-sym-##, so your symbolset must match these names for good results.",
    "keywords": [
      "STYLEITEM AUTO",
      "OGR FeatureStyle",
      "dynamic class",
      "CLASSITEM",
      "symbol matching",
      "mapinfo-sym",
      "label cache disabled",
      "mixed geometry",
      "incompatible geometry error",
      "layer TYPE"
    ]
  },
  {
    "id": 194,
    "text": "OGR style mapping converts OGR “tools” like PEN, BRUSH, and SYMBOL into MapServer STYLE objects. Typical mappings include PEN.c → STYLE.COLOR, PEN.w → STYLE.WIDTH, and PEN.p → STYLE.PATTERN, while brush/fill parameters map to polygon COLOR/OUTLINECOLOR and symbol parameters map to SYMBOL, SIZE, ANGLE, and offsets. Since MapServer 7.0, multiple OGR tools can be applied per feature: MapServer creates multiple STYLE blocks in the order tools appear, unless the OGR priority parameter (e.g., PEN.l / BRUSH.l / SYMBOL.l) is defined, in which case it controls the draw order. If styles render “out of order,” inspect the FeatureStyle string and priority fields.",
    "keywords": [
      "PEN",
      "BRUSH",
      "SYMBOL",
      "STYLE.COLOR",
      "STYLE.WIDTH",
      "STYLE.PATTERN",
      "priority parameter",
      "multiple STYLE objects",
      "FeatureStyle string",
      "MapServer 7.0"
    ]
  },
  {
    "id": 195,
    "text": "OGR STYLEITEM AUTO can expose label styling back to MapScript if you enable PROCESSING \"GETSHAPE_STYLE_ITEMS=all\" on the layer. Then getshape()/getValue() calls can access fields such as OGR:LabelText, OGR:LabelFont (comma-delimited fonts), OGR:LabelSize, OGR:LabelAngle, foreground/background colors, anchor/placement hints, x/y/perpendicular offsets, bold/italic/underline flags, and a priority value used to order style parts. This is useful for debugging why labels don’t match source styling, and for applications that need to read and reuse per-feature label properties outside of MapServer rendering.",
    "keywords": [
      "GETSHAPE_STYLE_ITEMS",
      "MapScript",
      "OGR:LabelText",
      "OGR:LabelFont",
      "LabelAngle",
      "Label colors",
      "Label offsets",
      "LabelAnchor",
      "label priority",
      "STYLEITEM AUTO"
    ]
  },
  {
    "id": 196,
    "text": "Oracle Spatial layers require Oracle client libraries on the server (the Instant Client is often sufficient), and MapServer must be compiled against a compatible Oracle client version. A common Windows symptom like “Error: .” is usually MapServer failing to locate ORACLE_HOME or required client DLLs. MapServer supports Oracle Spatial in two ways: native CONNECTIONTYPE oraclespatial (built-in driver), or via OGR using the OCI driver. The OGR approach is not available unless GDAL/OGR was compiled with Oracle support, which typically means rebuilding GDAL and then rebuilding MapServer against that GDAL.",
    "keywords": [
      "Oracle Spatial",
      "Oracle Locator",
      "Instant Client",
      "ORACLE_HOME",
      "client libraries",
      "CONNECTIONTYPE oraclespatial",
      "OCI driver",
      "GDAL rebuild",
      "plugin binaries",
      "error locating DLL"
    ]
  },
  {
    "id": 197,
    "text": "Native Oracle Spatial mapfile syntax uses CONNECTIONTYPE oraclespatial and a DATA clause that names the geometry column and source, with optional query helpers. Basic forms include \"GEOM FROM TABLE\", plus \"USING UNIQUE idcol\" (required for query modes/random access) and \"USING SRID ####\" when the table SRID is not NULL. DATA can also reference a subselect that returns SDO_GEOMETRY, letting you join tables or call spatial functions; if you use CLASSITEM/LABELITEM/FILTER, the subselect must return those fields. Variable binding is supported via BINDVALS name/value pairs to safely parameterize queries.",
    "keywords": [
      "oraclespatial",
      "DATA syntax",
      "SDO_GEOMETRY",
      "USING UNIQUE",
      "USING SRID",
      "subselect",
      "CLASSITEM",
      "LABELITEM",
      "FILTER",
      "BINDVALS"
    ]
  },
  {
    "id": 198,
    "text": "Oracle Spatial filtering behavior can be tuned in the DATA clause with function keywords. USING FILTER triggers SDO_FILTER (primary filter): fast and index-based, but can return a superset of exact hits. USING RELATE triggers SDO_RELATE (primary + secondary filters): slower but highly accurate when you need exact spatial relationships. USING GEOMRELATE calls SDO_GEOM.RELATE: accurate but does not use the spatial index, so it is the slowest. USING NONE disables spatial restriction entirely, which is useful when the source is a spatial function result or when there is no spatial index. If queries return nothing, verify the index and SRID assumptions first.",
    "keywords": [
      "SDO_FILTER",
      "SDO_RELATE",
      "SDO_GEOM.RELATE",
      "USING FILTER",
      "USING RELATE",
      "USING GEOMRELATE",
      "USING NONE",
      "spatial index",
      "performance vs accuracy",
      "Oracle query tuning"
    ]
  },
  {
    "id": 199,
    "text": "You can hint Oracle database version in the DATA clause with USING VERSION 8i/9i/10g to improve MapServer’s generated SQL, especially for geodetic SRIDs and extent calculations. Oracle connections can use a tnsnames.ora alias (CONNECTION \"user/pwd@MYDB\") once the client is configured. For OGR-based Oracle access, use CONNECTIONTYPE OGR with CONNECTION \"OCI:user/pwd@service\" and DATA \"TableName\". In WMS setups, set a static wms_extent in LAYER METADATA when possible; otherwise GetCapabilities can be slow because MapServer must compute extents through database calls.",
    "keywords": [
      "USING VERSION",
      "8i",
      "9i",
      "10g",
      "tnsnames.ora",
      "user/pwd@MYDB",
      "OCI",
      "wms_extent",
      "GetCapabilities performance",
      "geodetic SRID"
    ]
  },
  {
    "id": 200,
    "text": "PostGIS is MapServer’s native PostgreSQL spatial backend. Ensure the database has PostGIS enabled (CREATE EXTENSION postgis) and after upgrades run SELECT postgis_extensions_upgrade(). MapServer must be built with PostGIS support, and the PostgreSQL client library (libpq.so/libpq.dll) must be available in the system path. In the mapfile, set CONNECTIONTYPE POSTGIS and provide a CONNECTION string with dbname and user (host defaults to localhost, port to 5432). Many connectivity failures are caused by missing libpq at runtime or incorrect database credentials, so validate the runtime environment before tuning mapfile rendering settings.",
    "keywords": [
      "PostGIS",
      "PostgreSQL",
      "CREATE EXTENSION postgis",
      "postgis_extensions_upgrade",
      "libpq",
      "CONNECTIONTYPE POSTGIS",
      "connection string",
      "dbname",
      "port 5432",
      "runtime environment"
    ]
  },
  {
    "id": 201,
    "text": "The PostGIS DATA clause looks like: \"geomcol from table_or_subquery using unique idcol using srid=4326\". “using unique” is optional for drawing, but required for MapServer query operations; if you forget it, queries may fail and you may see errors like “column oid does not exist…”. MapServer used to fall back to PostgreSQL OIDs, but OIDs were removed in PostgreSQL 12, so always specify a real primary key. If your table lacks one, add it (ALTER TABLE mytable ADD COLUMN unique_id SERIAL PRIMARY KEY) and use that column in the DATA clause for stable random access and filtering.",
    "keywords": [
      "PostGIS DATA",
      "using unique",
      "using srid",
      "primary key",
      "oid does not exist",
      "PostgreSQL 12",
      "SERIAL PRIMARY KEY",
      "query operations",
      "random access",
      "mapfile troubleshooting"
    ]
  },
  {
    "id": 202,
    "text": "PostGIS layers can push complex SQL into the database by using a subquery: everything between “from” and “using” is evaluated server-side and must end with “as subquery”. This enables joins, attribute enrichment, and geometry functions like ST_Simplify, plus ORDER BY/LIMIT to reduce vertices and features before MapServer renders. Normally MapServer appends a bounding-box predicate automatically, but you can control placement with the !BOX! token (e.g., inside a nested WHERE) for better planner choices in complex SQL. If performance is poor, simplify geometry earlier and avoid expensive functions on unfiltered tables.",
    "keywords": [
      "SQL subquery",
      "as subquery",
      "ST_Simplify",
      "ORDER BY",
      "LIMIT",
      "!BOX!",
      "bounding box",
      "query planner",
      "performance",
      "PostGIS optimization"
    ]
  },
  {
    "id": 203,
    "text": "Even when using MapServer’s native PostGIS driver, GDAL/OGR tools can help diagnose database visibility. ogrinfo --formats should list the PostgreSQL/PG driver, and ogrinfo \"PG:dbname=… user=… password=…\" can confirm the server is reachable and list available layers/tables. If ogrinfo cannot connect or the driver is missing, MapServer deployments that rely on OGR-based database access (or data conversion with ogr2ogr) will fail too. Use this separation to decide whether you have a database/network problem, a GDAL build issue, or a mapfile syntax problem.",
    "keywords": [
      "ogrinfo",
      "PostgreSQL driver",
      "PG: connection string",
      "GDAL tools",
      "reachability test",
      "list tables",
      "OGR-based access",
      "ogr2ogr",
      "network debugging",
      "driver missing"
    ]
  },
  {
    "id": 204,
    "text": "A typical PostGIS vector layer uses CONNECTIONTYPE POSTGIS, a libpq-style CONNECTION string, and a DATA clause like \"wkb_geometry FROM province USING UNIQUE ogc_fid USING SRID=3978\". For performance, provide an explicit EXTENT and set PROCESSING \"CLOSE_CONNECTION=DEFER\" so one database session can be reused during a map draw. ogrinfo -summary is a quick way to confirm the table's extent, SRID, FID column, and geometry column before debugging the mapfile. If the layer draws blank, mismatched PROJECTION/SRID or a wrong geometry column name are the first things to check.",
    "keywords": [
      "PostGIS",
      "CONNECTIONTYPE POSTGIS",
      "DATA clause",
      "USING UNIQUE",
      "USING SRID",
      "EXTENT",
      "CLOSE_CONNECTION=DEFER",
      "ogrinfo -summary",
      "FID column",
      "projection mismatch"
    ]
  },
  {
    "id": 205,
    "text": "PostGIS 2.0+ can store raster tiles (PGRaster) and MapServer reads them through GDAL's PostGISRaster driver. Ensure the database has the extension loaded (CREATE EXTENSION postgis_raster) and use raster2pgsql to import GeoTIFFs. When loading, tile the raster (-t), build a GiST index (-I), apply raster constraints (-C), and optionally add a filename column (-F). If the raster layer renders slowly or times out, missing tiling and indexes are common causes. Use gdalinfo with a PG: connection string to list raster subdatasets and confirm the table/column names.",
    "keywords": [
      "PostGIS Raster",
      "PostGISRaster driver",
      "CREATE EXTENSION postgis_raster",
      "raster2pgsql",
      "tile -t",
      "GiST index -I",
      "constraints -C",
      "filename column -F",
      "gdalinfo PG:",
      "subdatasets"
    ]
  },
  {
    "id": 206,
    "text": "A PostGIS raster layer in a mapfile looks like a normal TYPE RASTER layer, but the connection parameters live inside DATA, using GDAL's PG: syntax (host/port/user/dbname plus schema, table, and column). When the raster was loaded as tiles, mode=2 must be present in the DATA string so MapServer can read it correctly. Add PROJECTION for the raster SRID and consider PROCESSING \"CLOSE_CONNECTION=DEFER\". map2img -map_debug 3 is useful for confirming that msDrawRasterLayerLow() is being called and that the outputformat is working.",
    "keywords": [
      "TYPE RASTER",
      "PG: connection string",
      "mode=2",
      "tiled raster",
      "PROJECTION init=epsg",
      "CLOSE_CONNECTION=DEFER",
      "map2img",
      "-map_debug 3",
      "msDrawRasterLayerLow",
      "outputformat"
    ]
  },
  {
    "id": 207,
    "text": "PostGIS can hold 2.5D geometries with Z/M values. MapServer will account for these geometries when built with WITH_POINT_Z_M enabled (as of MapServer 7.0). If you need to force classic 2D behavior (for example, to avoid downstream Z-related issues), set PROCESSING \"FORCE2D=YES\" on the PostGIS layer. When serving 2.5D features through WFS, extra layer-level metadata may be required so clients receive Z/M coordinates as expected. If clients report missing Z values, verify both the build flags and the WFS layer metadata.",
    "keywords": [
      "2.5D geometries",
      "Z/M coordinates",
      "WITH_POINT_Z_M",
      "FORCE2D=YES",
      "PostGIS layer",
      "WFS output",
      "layer METADATA",
      "build options",
      "MapServer 7.0",
      "vertical component"
    ]
  },
  {
    "id": 208,
    "text": "PostGIS supports SQL/MM curve geometries such as CircularString, CompoundCurve, CurvePolygon, MultiCurve, and MultiSurface. MapServer 6.0+ can draw these curve types directly from PostGIS, so the DATA clause can reference the geometry column normally (e.g., \"g FROM test USING UNIQUE id\"). On older MapServer versions (<6.0), curves can be forced to linear geometries using ST_CurveToLine() inside a SQL subquery, but it is much slower and can become a performance bottleneck. If you see unexpected rendering or crashes, confirm whether your MapServer build actually supports curve types.",
    "keywords": [
      "SQL/MM curves",
      "CircularString",
      "CompoundCurve",
      "CurvePolygon",
      "MultiSurface",
      "MultiCurve",
      "ST_CurveToLine",
      "MapServer 6.0",
      "curve rendering",
      "performance bottleneck"
    ]
  },
  {
    "id": 209,
    "text": "SDTS is a USGS exchange format with both raster and vector variants; MapServer supports only SDTS vector (VTP and DLG), not the raster flavor. Access is via OGR's SDTS driver, using CONNECTIONTYPE OGR and a CONNECTION pointing to the SDTS catalog file (____CATD.DDF, including the extension). SDTS catalogs contain multiple layers, and some are attribute-only with no geometry, so choosing the correct DATA layer name matters. Note that the SDTS driver was removed in GDAL 3.11, so \"driver not found\" errors can indicate an upgrade, not a mapfile mistake.",
    "keywords": [
      "SDTS",
      "USGS",
      "VTP",
      "DLG",
      "CONNECTIONTYPE OGR",
      "____CATD.DDF",
      "OGR SDTS driver",
      "attribute-only layers",
      "GDAL 3.11 removal",
      "driver not found"
    ]
  },
  {
    "id": 210,
    "text": "S-57 (IHO S-57) datasets are maritime chart files with a .000 extension (ENC-style). MapServer reads S-57 through OGR's S57 driver: set CONNECTIONTYPE OGR, point CONNECTION to the .000 file (absolute or via SHAPEPATH), and set DATA to an S-57 layer name such as DEPARE. A common failure is msOGRFileOpen() errors because GDAL cannot find s57objectclasses.csv and s57attributes.csv. Fix this by pointing MapServer to the GDAL data directory with a map-level CONFIG GDAL_DATA (for example, on Windows in MS4W).",
    "keywords": [
      "S-57",
      "ENC .000",
      "OGR S57 driver",
      "DEPARE layer",
      "msOGRFileOpen",
      "s57objectclasses.csv",
      "s57attributes.csv",
      "CONFIG GDAL_DATA",
      "SHAPEPATH",
      "maritime charts"
    ]
  },
  {
    "id": 211,
    "text": "SpatiaLite is a spatial extension for the file-based SQLite database, where geometries are stored as BLOB columns and registered in geometry_columns. MapServer accesses SpatiaLite through GDAL/OGR's SQLite driver (available in GDAL/OGR 1.7+). In a mapfile, use CONNECTIONTYPE OGR, set CONNECTION to the .sqlite/.db file, and set DATA to the name of a spatial table (OGR layer). Start by confirming that ogrinfo --formats lists the SQLite driver, then run ogrinfo <dbfile> to list available spatial layers. If there are no layers, the table may not be registered in geometry_columns.",
    "keywords": [
      "SpatiaLite",
      "SQLite driver",
      "geometry_columns",
      "BLOB geometry",
      "CONNECTIONTYPE OGR",
      "CONNECTION .sqlite",
      "DATA layername",
      "ogrinfo --formats",
      "GDAL/OGR 1.7+",
      "spatial tables"
    ]
  },
  {
    "id": 212,
    "text": "SpatiaLite layers can be defined using either simple table names or SQL in the DATA string. A standard approach is DATA \"mn_counties\" plus a MapServer FILTER like ('[fips]'='27031'). Alternatively, you can push filtering into SQL with DATA \"SELECT geometry FROM mn_counties WHERE fips='27031'\". More complex cases use joined queries to pull extra attributes (e.g., joining county_data to mn_counties). When debugging empty results, decide whether the filter is being applied by MapServer (FILTER) or by the driver (SQL WHERE), and confirm the selected geometry column name in the SQL matches the table schema.",
    "keywords": [
      "SpatiaLite SQL",
      "DATA SELECT",
      "FILTER expression",
      "WHERE clause",
      "join query",
      "mn_counties",
      "fips filter",
      "geometry column",
      "OGR SQL",
      "empty results"
    ]
  },
  {
    "id": 213,
    "text": "USGS TIGER/Line files are directory-based datasets from the U.S. Census Bureau. A typical county folder (e.g., TGR06059) contains multiple associated .RT* files, and MapServer reads them via OGR's TIGER driver. Use CONNECTIONTYPE OGR and point CONNECTION to the directory (not a single file); ogrinfo will list layers such as CompleteChain (LineString) and Landmark points. A basic mapfile uses DATA \"CompleteChain\" and LAYER TYPE LINE. The warning about update support is normal (read-only). If MapServer errors on open, verify permissions and that the directory name is correct.",
    "keywords": [
      "TIGER/Line",
      "US Census Bureau",
      "OGR TIGER driver",
      "directory datasource",
      "TGR06059",
      "CompleteChain",
      "CONNECTIONTYPE OGR",
      "DATA CompleteChain",
      "LineString",
      "read-only warning"
    ]
  },
  {
    "id": 214,
    "text": "UVraster is a hybrid vector-field layer type that converts a two-band raster (U and V components) into point features rendered as arrows. It was added in MapServer 6.2 and is used for wind/current visualization. Because the input is a raster, raster processing options such as RESAMPLE apply (AVERAGE is the default and often works well). The generated output is vector points, but queries are not supported. MapServer computes magnitude and rotation from U/V at each sample location, exposing attributes like [uv_angle] and [uv_length]. If arrows point the wrong way, verify band order and units in the source raster.",
    "keywords": [
      "uvraster",
      "vector field",
      "U/V bands",
      "wind direction",
      "magnitude",
      "RESAMPLE=AVERAGE",
      "hybrid layer",
      "[uv_angle]",
      "[uv_length]",
      "queries not supported"
    ]
  },
  {
    "id": 215,
    "text": "A UVraster layer is defined with CONNECTIONTYPE uvraster, DATA pointing to a raster such as a GRIB2 file, and PROCESSING \"BANDS=1,2\" to select U and V bands. Control arrow density with PROCESSING \"UV_SPACING=40\" (pixels between arrows) and scale the arrow size with PROCESSING \"UV_SIZE_SCALE=0.2\". Styling typically uses multiple SYMBOL definitions (shaft, head, tail) with ANGLE [uv_angle] and SIZE expressions driven by [uv_length]. POLAROFFSET can place the head and tail relative to the computed vector length and direction. Debugging usually focuses on missing bands, wrong scaling, or symbol definitions.",
    "keywords": [
      "CONNECTIONTYPE uvraster",
      "GRIB2",
      "BANDS=1,2",
      "UV_SPACING",
      "UV_SIZE_SCALE",
      "SYMBOL",
      "ANGLE [uv_angle]",
      "SIZE [uv_length]",
      "POLAROFFSET",
      "TYPE POINT"
    ]
  },
  {
    "id": 216,
    "text": "Virtual Spatial Data uses OGR's VRT driver to create geometry from non-spatial tables or flat text files that contain X and Y columns. MapServer can then draw the data via an ODBC datasource (or direct text access), even when the original source has no geometry type. The approach works with many ODBC databases (Oracle, MySQL, SQL Server, Access, PostgreSQL) and with comma/tab/custom-delimited files. The key idea is to describe how to build points from columns (e.g., Long/Lat) inside a VRT (.ovf) file. This is useful when you need quick mapping of tabular data without a spatial ETL step.",
    "keywords": [
      "Virtual Spatial Data",
      "OGR VRT",
      "ODBC",
      "non-spatial tables",
      "text files",
      "X/Y columns",
      "VRT .ovf",
      "GeometryField",
      "PointFromColumns",
      "unknown geometry"
    ]
  },
  {
    "id": 217,
    "text": "A typical Virtual Spatial Data workflow is: create an ODBC DSN (often a SYSTEM DSN on Windows), test it with ogrinfo, then write a VRT (.ovf) that references the DSN and source layer (for example, coal_dep.txt) and defines GeometryField encoding=\"PointFromColumns\" with x/y column names. Test the VRT with ogrinfo <ovf> <layername> (expect read-only warnings). In the mapfile, use CONNECTIONTYPE OGR and set CONNECTION to the ovf file (absolute path or relative via SHAPEPATH/mapfile location), with DATA matching the VRT layer name. If map2img works but the app fails, DSN scope/permissions are a prime suspect.",
    "keywords": [
      "ODBC DSN",
      "SYSTEM DSN",
      "ogrinfo ODBC:",
      "VRT ovf",
      "PointFromColumns",
      "SHAPEPATH rules",
      "CONNECTIONTYPE OGR",
      "map2img",
      "read-only warning",
      "permissions"
    ]
  },
  {
    "id": 218,
    "text": "MapServer can act as a WFS client, reading remote vector features from an external Web Feature Service. It supports WFS 1.0.0 and can also access WFS sources indirectly through the OGR WFS driver. A WFS server advertises layers via GetCapabilities, describes schemas via DescribeFeatureType, and returns features via GetFeature. WFS layers in MapServer are configured as LAYER objects (often TYPE POLYGON/LINE/POINT) that point to the remote service URL. When debugging, confirm the service responds to GetCapabilities and that the requested typeName exists and has the expected geometry type.",
    "keywords": [
      "WFS client",
      "Web Feature Service",
      "GetCapabilities",
      "DescribeFeatureType",
      "GetFeature",
      "WFS 1.0.0",
      "OGR WFS driver",
      "remote typename",
      "service URL",
      "empty results"
    ]
  },
  {
    "id": 219,
    "text": "A WFS client layer uses CONNECTIONTYPE WFS and a CONNECTION set to the base service URL. Put name/value pairs in a METADATA block, such as \"wfs_typename\" \"dm:stry2003_klb\" and \"wfs_version\" \"1.0.0\". Optional metadata can limit requests or improve stability (e.g., connection timeout, max features, or server-side filters), and you should set a LAYER PROJECTION (often EPSG:4326) to match the service. If requests are slow or fail intermittently, check timeouts and the volume of features returned by GetFeature, and consider restricting the requested extent or attributes.",
    "keywords": [
      "CONNECTIONTYPE WFS",
      "METADATA",
      "wfs_typename",
      "wfs_version",
      "EPSG:4326",
      "timeout",
      "max features",
      "server-side filter",
      "remote service",
      "performance"
    ]
  },
  {
    "id": 220,
    "text": "The Raster Data chapter begins by outlining how MapServer handles raster sources and common workflows: supported file formats through GDAL, serving imagery via WMS, and techniques such as tiling, resampling, and warping. The section also covers higher-level patterns like tile indexes for mosaics, color tables and classification, and performance considerations when reading large rasters. Raster debugging often starts with confirming georeferencing (projection, extent, pixel size) and then verifying which band(s) are being read. When you see blank tiles or shifted images, the usual suspects are missing projection definitions, wrong extents, or misapplied resampling/warping settings.",
    "keywords": [
      "Raster Data",
      "GDAL formats",
      "tiling",
      "resampling",
      "warping",
      "tileindex mosaics",
      "color tables",
      "georeferencing",
      "blank raster",
      "extent mismatch"
    ]
  },
  {
    "id": 221,
    "text": "The Raster Data section explains how MapServer renders raster sources and which workflows are supported. Modern MapServer reads rasters through GDAL, so features like reprojection, resampling, color correction, and overview selection depend on the GDAL driver. This chapter focuses on raster-specific mapfile syntax, how pixel values are interpreted during rendering and querying, and how preprocessing (tiling, overviews, palette reduction) can improve speed. It also notes common troubleshooting themes: projection mismatches that trigger expensive warping, and file path issues that prevent rasters from loading.",
    "keywords": [
      "raster data",
      "GDAL",
      "raster renderer",
      "mapfile syntax",
      "preprocessing",
      "tiling",
      "overviews",
      "palette reduction",
      "troubleshooting",
      "resampling"
    ]
  },
  {
    "id": 222,
    "text": "A basic raster layer in a mapfile uses TYPE RASTER and a DATA filename resolved relative to SHAPEPATH (similar to vector layers). Raster layers can include PROJECTION, METADATA, PROCESSING, MINSCALEDENOM/MAXSCALEDENOM, and other scale controls. They cannot use labels, CONNECTION/CONNECTIONTYPE, or FEATURE definitions like vector layers. When imagery does not draw, confirm the DATA path, SHAPEPATH, and file permissions, then verify the dataset with gdalinfo and ensure the layer and map projections are consistent.",
    "keywords": [
      "LAYER TYPE RASTER",
      "DATA",
      "SHAPEPATH",
      "PROJECTION",
      "METADATA",
      "PROCESSING",
      "MINSCALEDENOM",
      "MAXSCALEDENOM",
      "missing imagery",
      "gdalinfo"
    ]
  },
  {
    "id": 223,
    "text": "Raster classification resembles vector classification but is pixel-driven. You usually do not set CLASSITEM; the raw pixel value is available as \"[pixel]\" and, for paletted rasters, the associated color components \"[red]\", \"[green]\", and \"[blue]\" are available in expressions. When evaluated, these keywords must be lowercase (for example, [pixel]). Classes are tested in order and the first match wins; only NAME, EXPRESSION, and COLOR are used for raster styling, and other style directives are ignored.",
    "keywords": [
      "raster classification",
      "[pixel]",
      "[red]",
      "[green]",
      "[blue]",
      "EXPRESSION",
      "CLASS order",
      "COLOR",
      "paletted raster",
      "CLASSITEM"
    ]
  },
  {
    "id": 224,
    "text": "MapServer can classify non‑8bit rasters (values outside 0–255) by scaling inputs before classification. A common pattern is PROCESSING \"SCALE=min,max\" plus \"SCALE_BUCKETS=256\" to stretch values into the 0–255 range, then PROCESSING \"CLASSIFY_SCALED=TRUE\" so your class expressions operate on scaled bytes. This is useful for 16‑bit or floating-point grids such as elevation or temperature. If output becomes “all one class,” verify the source data range and whether expressions are applied to scaled or raw values.",
    "keywords": [
      "non-8bit raster",
      "16-bit",
      "floating point grid",
      "SCALE",
      "SCALE_BUCKETS",
      "CLASSIFY_SCALED",
      "data range",
      "class expressions",
      "byte stretch"
    ]
  },
  {
    "id": 225,
    "text": "Since MapServer 6.2, raster input is handled through GDAL only. GDAL is installed separately and enabled when building MapServer (for example, using a --with-gdal configuration option). To confirm support, run mapserv -v to list build flags and use \"gdalinfo --formats\" to see available raster drivers. Advanced capabilities like resampling kernels, RGB quantization options, and automatic projection capture rely on GDAL-backed formats. For PostGIS raster (PGRaster), MapServer uses a separate PostGIS workflow.",
    "keywords": [
      "supported formats",
      "GDAL drivers",
      "--with-gdal",
      "mapserv -v",
      "gdalinfo --formats",
      "GDAL build",
      "raster input",
      "PostGIS raster",
      "PGRaster"
    ]
  },
  {
    "id": 226,
    "text": "For very large mosaics, MapServer can manage many raster tiles through a TILEINDEX shapefile. The shapefile contains polygons (often rectangles) representing each tile footprint and an attribute (set by TILEITEM) holding the raster filename. With TILEINDEX configured, MapServer scans the index and opens only the tiles intersecting the current map request, improving performance. Tiles may vary in size and format and can overlap, with later tiles drawing over earlier ones. In tileindex raster layers, a separate DATA statement is not required.",
    "keywords": [
      "TILEINDEX",
      "TILEITEM",
      "raster mosaic",
      "tile footprints",
      "shapefile index",
      "overlapping tiles",
      "performance",
      "open intersecting tiles",
      "DATA omitted"
    ]
  },
  {
    "id": 227,
    "text": "Tile index failures are often path failures. Filenames stored in the tileindex should resolve relative to SHAPEPATH when set; ambiguous relative paths are a common reason for “cannot open” errors. A robust approach is to place the tileindex under SHAPEPATH and store tile paths that are valid from that directory, or temporarily switch to absolute paths to eliminate ambiguity. GDAL’s gdaltindex utility can build tileindex shapefiles, and it records filenames exactly as provided. If tiles are in different projections, MapServer can support this with TILESRS and additional index-building options.",
    "keywords": [
      "tile index paths",
      "relative paths",
      "absolute paths",
      "SHAPEPATH evaluation",
      "gdaltindex",
      "file not found",
      "TILESRS",
      "mixed projections",
      "troubleshooting"
    ]
  },
  {
    "id": 228,
    "text": "Raster warping (on-the-fly reprojection and rotation) is available for GDAL rasters. Warping is triggered when the raster layer projection differs from the MAP projection, and it can also handle rasters with rotation coefficients in their georeferencing. Warped rasters are significantly more expensive to render (often 2–4× slower) because MapServer computes transformation points and interpolates along scanlines while keeping error below a fraction of a pixel. If performance drops, check whether the layer projection unexpectedly differs from the map projection or if datum shifts are involved.",
    "keywords": [
      "raster warping",
      "on-the-fly reprojection",
      "MAP projection",
      "layer projection",
      "rotation coefficients",
      "performance hit",
      "scanline interpolation",
      "GDAL warper"
    ]
  },
  {
    "id": 229,
    "text": "When a 24‑bit raster (RGB) is rendered into an 8‑bit output format (IMAGEMODE PC256), MapServer must quantize colors into a 256-entry palette. By default it uses a fixed “color cube” (175 colors: 5×7×5) plus extra grayscale entries and maps each input pixel to the nearest entry. This can degrade smooth imagery and quickly consumes the palette, affecting other layers. PROCESSING \"DITHER=YES\" enables error diffusion to improve perceived color quality, but it increases CPU cost and should be used only when truecolor outputs are not possible.",
    "keywords": [
      "24-bit RGB",
      "PC256",
      "IMAGEMODE",
      "color cube",
      "palette quantization",
      "colormap exhaustion",
      "DITHER",
      "error diffusion",
      "truecolor vs paletted"
    ]
  },
  {
    "id": 230,
    "text": "For truecolor imagery, it is often better to produce 24‑bit or 32‑bit output rather than quantizing to PC256. OUTPUTFORMAT can be configured with IMAGEMODE RGB (24‑bit) or IMAGEMODE RGBA (32‑bit with alpha) to preserve source colors and avoid colormap exhaustion. Default imagetypes such as png24 or jpeg are common choices. If transparency is required, prefer RGBA outputs and ensure the dataset provides an alpha band or that opacity is derived from a mask band when supported.",
    "keywords": [
      "OUTPUTFORMAT",
      "IMAGEMODE RGB",
      "IMAGEMODE RGBA",
      "png24",
      "jpeg output",
      "truecolor rendering",
      "alpha transparency",
      "avoid PC256",
      "color fidelity"
    ]
  },
  {
    "id": 231,
    "text": "The PROCESSING parameter on a raster LAYER passes GDAL-oriented rendering options. One key directive is BANDS=red_or_grey[,green,blue[,alpha]], which selects which bands are used for rendering: one band for grayscale, three for RGB, four for RGBA. Starting with MapServer 8, a GDAL mask band attached to the raster (not an alpha band) is automatically used for opacity rendering when BANDS is specified, unless PROCESSING \"USE_MASK_BAND=NO\" is set. Mis-specified BANDS is a frequent cause of “wrong colors” or “unexpected transparency” problems.",
    "keywords": [
      "PROCESSING",
      "BANDS",
      "RGBA",
      "grayscale band",
      "mask band",
      "USE_MASK_BAND",
      "opacity",
      "wrong colors",
      "GDAL bands"
    ]
  },
  {
    "id": 232,
    "text": "PROCESSING \"CLASSIFY_SCALED=YES/NO\" (added in 7.6) allows classification to use pre-scaled raster data for 16‑bit sources. Typically you define PROCESSING \"SCALE=min,max\" and \"SCALE_BUCKETS=256\" so values are stretched into 0–255, then enable CLASSIFY_SCALED so class expressions behave like traditional byte classification. This helps reuse class rules across byte and 16‑bit datasets. If classes do not match as expected, confirm the SCALE range and whether expressions are applied before or after scaling.",
    "keywords": [
      "CLASSIFY_SCALED",
      "SCALE",
      "SCALE_BUCKETS",
      "16-bit classification",
      "byte classes",
      "stretch to 0-255",
      "class rules reuse",
      "raster expressions"
    ]
  },
  {
    "id": 233,
    "text": "PROCESSING \"COLOR_MATCH_THRESHOLD=n\" relaxes strict palette matching when building an 8‑bit colormap (PC256). Instead of requiring exact matches, MapServer can reuse an existing palette entry if the color distance is within n (sum of RGB differences). Values around 2–6 are often useful, especially for grayscale rasters that would otherwise consume all 256 entries and “steal” palette slots from other layers. Related directives include DITHER=YES for 24→8 bit error diffusion and EXTENT_PRIORITY=WORLD to force world-file extents over GDAL-reported extents when georeferencing is wrong.",
    "keywords": [
      "COLOR_MATCH_THRESHOLD",
      "PC256 palette",
      "grayscale raster",
      "reuse palette entry",
      "DITHER",
      "EXTENT_PRIORITY",
      "world file override",
      "palette stealing",
      "color distance"
    ]
  },
  {
    "id": 234,
    "text": "Appearance and warp troubleshooting can rely on several processing controls. PROCESSING \"GAMMA=value\" (MapServer 8.4+) applies gamma correction after classification (default 1.0) and does not affect raw (unclassified) rendering. For difficult reprojections, LOAD_FULL_RES_IMAGE=YES forces the resampler to load full-resolution data, and LOAD_WHOLE_IMAGE=YES loads the entire dataset to avoid missing areas near datelines or projection horizons. Both options can dramatically increase processing time and memory use, so enable them only when you are diagnosing or working around resampling bugs.",
    "keywords": [
      "GAMMA",
      "gamma correction",
      "LOAD_FULL_RES_IMAGE",
      "LOAD_WHOLE_IMAGE",
      "radical warping",
      "dateline issues",
      "projection horizon",
      "memory usage",
      "resampler"
    ]
  },
  {
    "id": 235,
    "text": "PROCESSING \"LUT\" and \"LUT_n\" (MapServer 4.9+) apply a lookup table for on-the-fly color correction. LUT applies to all bands; LUT_1..LUT_4 target specific bands (red, green, blue, alpha). A LUT can be inline pairs like \"100:30,160:128,210:200\" with linear interpolation (0:0 and 255:255 are implied), or it can be loaded from a text file searched relative to the mapfile. Since MapServer 7.2, LUT input ranges can extend to 65535 (for example, 4095:255 for 12‑bit data). GIMP curve files can also be used and are internally approximated with linear segments.",
    "keywords": [
      "LUT",
      "LUT_1",
      "lookup table",
      "color correction",
      "GIMP curves",
      "extended LUT 65535",
      "linear interpolation",
      "mapfile relative path",
      "band-specific LUT"
    ]
  },
  {
    "id": 236,
    "text": "Resampling choices strongly affect raster quality and speed. PROCESSING \"RESAMPLE=NEAREST\" is the default and fastest. RESAMPLE=AVERAGE computes averages over contributing pixels, reducing noise and providing a form of anti-aliasing when downsampling. RESAMPLE=BILINEAR interpolates between nearby pixels and can look smoother when oversampling. Non-NEAREST kernels usually route rendering through the generalized warper, which can dramatically slow requests. OVERSAMPLE_RATIO (default about 2.5) controls how much oversampling is allowed before scaling back, trading speed for visual quality.",
    "keywords": [
      "RESAMPLE",
      "NEAREST",
      "AVERAGE",
      "BILINEAR",
      "generalized warper",
      "OVERSAMPLE_RATIO",
      "antialiasing",
      "performance vs quality",
      "downsampling"
    ]
  },
  {
    "id": 237,
    "text": "PROCESSING \"SCALE\" (or SCALE_1/SCALE_2/SCALE_3) instructs GDAL to pre-scale incoming raster data, commonly stretching 16‑bit or float values into 0–255 or contrast-stretching 8‑bit data. SCALE can be AUTO (compute min/max) or an explicit min,max range, and per-band SCALE_n is useful for multi-band imagery. For georeferencing overrides, PROCESSING \"WORLDFILE\" can specify an alternate world file path or a full filename (suffix like .wld/.tfw can be omitted). These controls help when GDAL metadata is missing or incorrect and the raster draws in the wrong place.",
    "keywords": [
      "SCALE=AUTO",
      "SCALE_1",
      "contrast stretch",
      "16-bit to 8-bit",
      "WORLDFILE",
      "georeferencing override",
      "min/max scaling",
      "GDAL metadata fix"
    ]
  },
  {
    "id": 238,
    "text": "Raster labelling (added in 8.4) renders labels derived from raster pixel values, useful for temperature, slopes, pollution, and similar grids. It is a hybrid approach: input is raster but output is a point feature set for labelling, and queries are not supported. In the mapfile, use TYPE POINT with CONNECTIONTYPE RASTERLABEL and set DATA to the raster dataset. The primary attribute is [value] (raw pixel value). Optional PROCESSING settings include BANDS (band to label), LABEL_SPACING (pixel spacing between points, default 32), RESAMPLE (defaults to AVERAGE), and ALLOW_OVERSAMPLE (default NO).",
    "keywords": [
      "RasterLabelling",
      "CONNECTIONTYPE RASTERLABEL",
      "TYPE POINT",
      "[value] attribute",
      "LABEL_SPACING",
      "BANDS",
      "RESAMPLE=AVERAGE",
      "ALLOW_OVERSAMPLE",
      "hybrid layer"
    ]
  },
  {
    "id": 239,
    "text": "A typical raster labelling layer formats label text from [value] using expressions (for example, tostring([value],\"%.1f\")+\"°\"). Because ALLOW_OVERSAMPLE defaults to NO, zooming beyond the raster’s native resolution produces at most one point per source pixel, making the displayed label density reflect the dataset resolution. If labels appear too dense or sparse, adjust LABEL_SPACING and consider a different RESAMPLE method. Since rasterlabelling outputs points, you style labels with standard CLASS/LABEL blocks like any other point layer.",
    "keywords": [
      "rasterlabel example",
      "TEXT expression",
      "tostring()",
      "units formatting",
      "label density",
      "ALLOW_OVERSAMPLE=NO",
      "resolution feedback",
      "CLASS LABEL",
      "mapfile"
    ]
  },
  {
    "id": 240,
    "text": "Raster querying (added in 4.4) supports QueryByPoint, QueryByRect, and QueryByShape on raster layers, returning one point feature per pixel that matches. QueryByPoint supports single or multiple results, but operations like QueryByAttributes, QueryByIndex, or QueryByFeature are not supported. Raster layers must have a query TEMPLATE to be queryable (even if a method does not use it directly). Raster queries cannot be saved to disk and do not support query maps. Returned attributes can include x/y (georeferenced pixel location), value_list, value_n per band, class name, and red/green/blue display components.",
    "keywords": [
      "RasterQuery",
      "QueryByPoint",
      "QueryByRect",
      "QueryByShape",
      "query TEMPLATE",
      "pixel features",
      "value_list",
      "value_n",
      "class attribute",
      "query limitations"
    ]
  },
  {
    "id": 241,
    "text": "Band selection and result limits are critical for raster queries. The query normally reports the same band(s) used for rendering, but a query-only layer can use PROCESSING \"BANDS=1,2,3,...\" to return more band values than a render would allow (for example, all 7 bands of a Landsat scene). Each returned pixel requires significant temporary memory (on the order of 100+ bytes), so large query areas can exhaust RAM. Use PROCESSING \"RASTER_QUERY_MAX_RESULT=n\" to cap the number of pixel features returned; the default is one million results, which can reach around 100 MB of memory.",
    "keywords": [
      "BANDS query",
      "multiband query",
      "Landsat",
      "RASTER_QUERY_MAX_RESULT",
      "memory footprint",
      "pixel caching",
      "large query area",
      "query-only layer",
      "band values"
    ]
  },
  {
    "id": 242,
    "text": "Raster query results can be consumed through HTML templates (substituting [value_list], [value_0], etc.), via WMS GetFeatureInfo, or programmatically via MapScript. A typical MapScript flow is: queryByPoint, open the layer, iterate layer.getResult(i), fetch shapes with layer.getShape(result), then print item values. The red/green/blue attributes are intended to match the final rendered color, but can be subtly wrong in some classified floating-point cases, so treat them as best-effort diagnostics when validating classification and styling.",
    "keywords": [
      "WMS GetFeatureInfo",
      "MapScript",
      "query template",
      "getResult",
      "getShape",
      "pixel attributes",
      "red green blue",
      "diagnostics",
      "HTML substitution"
    ]
  },
  {
    "id": 243,
    "text": "Raster query results are treated internally as temporary features cached in RAM, and issuing a new query clears the existing cache. Because MapServer’s “saved query” mechanism stores feature IDs rather than full feature content, raster query results cannot be saved to disk in the same way as vector query results. If users report that query results disappear after a second query or map draw, this cache reset is the likely cause. For persistent analytics, capture the results immediately in your application layer (MapScript, WMS client, or template output).",
    "keywords": [
      "query cache",
      "in-memory features",
      "clears on new query",
      "cannot save raster queries",
      "feature IDs",
      "temporary results",
      "application capture",
      "RAM usage"
    ]
  },
  {
    "id": 244,
    "text": "Raster display performance often depends more on preprocessing than on mapfile tweaks. Build internal GDAL overviews (or separate overview layers) so MapServer touches less data when zoomed out; multi-resolution layer visibility can be controlled with MINSCALEDENOM/MAXSCALEDENOM. For tileindex mosaics, add a high-scale overview layer to avoid opening many files per request. Preprocess RGB imagery to 8‑bit paletted rasters when acceptable to reduce I/O and computation. Use tiling (TILEINDEX or internal tiling) and keep datasets in the most-requested projection to avoid expensive warping. If MapServer debug logs show msResampleGDALToMap, the layer is being resampled and you should re-check projections and georeferencing.",
    "keywords": [
      "performance tips",
      "GDAL overviews",
      "MINSCALEDENOM",
      "MAXSCALEDENOM",
      "tileindex overview",
      "preprocess RGB",
      "tiling",
      "avoid warping",
      "msResampleGDALToMap",
      "debugging"
    ]
  },
  {
    "id": 245,
    "text": "To improve access speed for large rasters, produce internally tiled datasets. GeoTIFF supports internal tiling with GDAL creation options; for example: gdal_translate -co TILED=YES original.tif tiled.tif. Erdas Imagine (HFA) datasets are always tiled and can exceed the 4 GB size limits of classic GeoTIFF, so translating to .img can be practical for huge mosaics: gdal_translate -of HFA original.tif tiled.img. Internal tiling reduces overhead when MapServer reads a small geographic window from a large raster, improving interactive map performance.",
    "keywords": [
      "gdal_translate",
      "TILED=YES",
      "GeoTIFF tiling",
      "HFA",
      "Erdas Imagine",
      "large rasters",
      "4GB limit",
      "windowed reads",
      "preprocessing"
    ]
  },
  {
    "id": 246,
    "text": "Reducing 24‑bit RGB imagery to an 8‑bit paletted dataset can cut disk space, bandwidth, and render/compression time, but it also reduces color fidelity. MapServer can quantize on the fly, but preprocessing is usually faster. GDAL’s rgb2pct.py script builds a color table and applies error diffusion during conversion (for example: rgb2pct.py original.tif 8bit.tif). You can reduce to fewer than 256 colors with -n (for example, -n 200) to leave palette room for other map elements. Perform palette reduction before internal tiling and overview building for best results.",
    "keywords": [
      "rgb2pct.py",
      "RGB to palette",
      "8-bit",
      "color table",
      "error diffusion",
      "-n colors",
      "bandwidth reduction",
      "render speed",
      "palette room"
    ]
  },
  {
    "id": 247,
    "text": "Most GDAL formats can store internal overviews (pyramids) built with gdaladdo. For example: gdaladdo tiled.tif 2 4 8 16 32 64 128 creates decimated overview levels; by default it uses nearest-neighbour resampling, while -r average produces smoother results for some datasets. Some formats (JPEG2000, MrSID, ECW) already contain implicit overviews and may not benefit from external ones. Build overviews after translating to the final format, because gdal_translate conversions commonly drop existing overviews. MapServer will automatically use GDAL overviews when they exist.",
    "keywords": [
      "gdaladdo",
      "internal overviews",
      "pyramids",
      "nearest neighbour",
      "average resampling",
      "decimation levels",
      "format conversion",
      "GDAL overview selection",
      "JPEG2000 MrSID ECW"
    ]
  },
  {
    "id": 248,
    "text": "When a tileindex references many rasters, it can help to build external overview layers that “kick in” at high scales. One approach is to downsample and mosaic tiles with gdal_merge.py using a target pixel size (-ps), or use gdalwarp with target resolution (-tr) and resampling options. Another option is to let MapServer render an overview image via map2img against the tileindex layer, but you may need to temporarily adjust MAP EXTENT and SIZE to match the raster coverage and desired output. Avoid leaving huge overviews in slow-to-window formats like PNG when you need frequent subarea extraction.",
    "keywords": [
      "external overviews",
      "gdal_merge.py",
      "gdalwarp",
      "target resolution",
      "mosaic",
      "map2img overview",
      "MAP EXTENT",
      "MAP SIZE",
      "high scale layers",
      "PNG subwindow performance"
    ]
  },
  {
    "id": 249,
    "text": "World files provide a simple six-line georeferencing companion file for rasters, often used with TIFF when georeferencing is not embedded. The lines define X pixel size, two rotation/shear coefficients (normally 0), Y pixel size (usually negative because Y decreases downward), and the X/Y coordinates of the center of the top-left pixel. World file naming is derived from the raster name (for example, aerial.tif → aerial.tfw), but MapServer will accept the generic .wld extension reliably. If extents appear shifted or flipped, inspect world file signs and rotation terms.",
    "keywords": [
      "world files",
      ".wld",
      ".tfw",
      "georeferencing",
      "pixel size",
      "rotation coefficients",
      "top-left pixel center",
      "negative y pixel size",
      "extent errors"
    ]
  },
  {
    "id": 250,
    "text": "GDAL’s Virtual File System (VSI) lets MapServer read “virtual” vector and raster sources, such as datasets inside compressed archives or remote files via HTTP. Common VSI prefixes include /vsizip/, /vsigzip/, /vsitar/, and /vsicurl/. A practical workflow is to test access first with ogrinfo (vector) or gdalinfo (raster) using the same VSI path, then configure the MapServer layer. VSI is convenient for deployment but introduces overhead and new failure modes (compression, network range requests, timeouts), so debugging typically starts by reproducing the same path with GDAL command-line tools.",
    "keywords": [
      "Virtual File System",
      "GDAL VSI",
      "/vsizip/",
      "/vsicurl/",
      "/vsigzip/",
      "/vsitar/",
      "remote files",
      "compressed archives",
      "ogrinfo",
      "gdalinfo"
    ]
  },
  {
    "id": 251,
    "text": "To display a compressed dataset (for example, a shapefile inside test.zip), verify VSI support and inspect it with ogrinfo using a /vsizip/ path (e.g., /vsizip/test.zip/test.shp -summary). After confirming GDAL can open it, configure the MapServer layer to use the same VSI path. A common gotcha is that MapServer requires an absolute path in the CONNECTION when using /vsizip/ on local archives. You can sometimes omit the internal filename (test.shp) if the zip contains only the expected shapefile components, letting GDAL treat the zip like a directory.",
    "keywords": [
      "compressed shapefile",
      "/vsizip/",
      "ogrinfo -summary",
      "CONNECTIONTYPE OGR",
      "absolute path required",
      "zip as directory",
      "layer configuration",
      "GDALOpen"
    ]
  },
  {
    "id": 252,
    "text": "After configuring a virtual layer, test rendering with map2img and a high debug level (for example, -all_debug 5). Successful output often includes GDALOpen/GDALClose messages for the VSI path and counts of features read, which confirms the datasource is reachable and the layer configuration is correct. Map2img is also useful for reproducing server-side errors outside a web server context. Keep in mind that virtual layers have a performance cost compared to local datasets due to decompression, additional I/O, and (for remote data) HTTP range request overhead.",
    "keywords": [
      "map2img",
      "-all_debug",
      "GDALOpen messages",
      "virtual layer testing",
      "feature count",
      "performance cost",
      "decompression overhead",
      "server-side debugging"
    ]
  },
  {
    "id": 253,
    "text": "Remote rasters can be accessed over HTTP with /vsicurl/. Validate connectivity and driver support with gdalinfo on the exact VSI URL (for example, /vsicurl/https://.../small_world.tif) before configuring the MapServer layer. If rendering fails intermittently, enable GDAL curl debugging in the mapfile using MAP-level CONFIG entries such as CONFIG \"CPL_DEBUG\" \"ON\" and CONFIG \"CPL_CURL_VERBOSE\" \"ON\" to inspect HTTP transactions. Because MapServer relies on GDAL/OGR for both vector and raster access, the same VSI approach can be applied broadly once it works.",
    "keywords": [
      "remote raster",
      "/vsicurl/",
      "HTTP access",
      "gdalinfo test",
      "CPL_DEBUG",
      "CPL_CURL_VERBOSE",
      "MAP CONFIG",
      "range requests",
      "intermittent failures"
    ]
  },
  {
    "id": 254,
    "text": "MapServer’s AGG renderer (introduced in 5.0) uses OUTPUTFORMAT blocks to select the backend and image mode. Typical setups are AGG/PNG with IMAGEMODE RGB for 24‑bit PNG, AGG/PNG with IMAGEMODE RGBA for transparent backgrounds, and AGG/JPEG for smaller JPEG output. For palette reduction you can keep AGG/PNG but add FORMATOPTION settings such as QUANTIZE_FORCE, QUANTIZE_DITHER, and QUANTIZE_COLORS (e.g., 256). When troubleshooting “wrong colors” or unexpectedly large files, confirm you are using the intended OUTPUTFORMAT NAME and that the DRIVER matches AGG/PNG or AGG/JPEG.",
    "keywords": [
      "AGG renderer",
      "OUTPUTFORMAT",
      "AGG/PNG",
      "AGG/JPEG",
      "IMAGEMODE RGB",
      "IMAGEMODE RGBA",
      "quantization",
      "FORMATOPTION",
      "QUANTIZE_COLORS"
    ]
  },
  {
    "id": 255,
    "text": "With AGG, rendering is antialiased by default. As a result, mapfile ANTIALIAS settings are ignored, and older transparency workarounds like TRANSPARENCY ALPHA are not used the same way. Pixmap symbols and TrueType fonts are drawn using the image’s internal alpha channel (unless you explicitly set a background color), which can change the look of existing maps when migrating from GD. If output suddenly looks different after switching to AGG, check for assumptions about per-style ANTIALIAS behavior and verify whether a background color is forcing opaque rendering.",
    "keywords": [
      "antialias default",
      "ANTIALIAS ignored",
      "TRANSPARENCY ALPHA",
      "pixmap symbols",
      "font alpha channel",
      "background color",
      "GD vs AGG",
      "migration issues"
    ]
  },
  {
    "id": 256,
    "text": "AGG does not require “fake thickness” via ELLIPSE symbols: thick lines are normally drawn with STYLE WIDTH (e.g., WIDTH 5). When a line STYLE references a vector or pixmap SYMBOL, MapServer enables a line symbolizer to draw textured lines. For “shield” symbolization (markers placed periodically along a line), add a GAP parameter to the SYMBOL definition; the GAP distance is scaled by the STYLE SIZE. Use a positive GAP for symbols that keep a north-up orientation (optionally rotated by STYLE ANGLE), and a negative GAP when symbols should follow the line direction.",
    "keywords": [
      "STYLE WIDTH",
      "line symbolizer",
      "textured lines",
      "SYMBOL GAP",
      "shield symbols",
      "STYLE SIZE",
      "STYLE ANGLE",
      "line orientation"
    ]
  },
  {
    "id": 257,
    "text": "In AGG, POLYGON layers with OUTLINECOLOR can use the WIDTH keyword as a shorthand for outline thickness when no explicit outline STYLE is provided; this outline width is not scale-dependent. If you stamp a SYMBOL inside a polygon fill, the symbol’s GAP controls spacing between repeated symbols (vector, pixmap, or ellipse). Circle layers also support hatch-style symbol filling. Label ENCODING is enforced: if you omit ENCODING, MapServer treats label text byte-by-byte, which commonly appears as corrupted accented or non‑ASCII characters.",
    "keywords": [
      "POLYGON outline",
      "OUTLINECOLOR",
      "WIDTH shorthand",
      "symbol fill",
      "GAP spacing",
      "CIRCLE hatch fill",
      "LABEL ENCODING",
      "corrupt characters"
    ]
  },
  {
    "id": 258,
    "text": "The AntiAliasing how-to in this chapter applies mainly to the legacy GD renderer and is flagged as outdated. Since MapServer 6.0, the “gd/” output drivers produce aliased output, while “agg/” and “cairo/” produce antialiased output by design. If you see jagged edges and your OUTPUTFORMAT driver is GD, the simplest fix is usually to switch to an AGG or Cairo driver rather than tuning per-STYLE ANTIALIAS. Use this document only when you are forced to stay on GD (or are working with very old MapServer versions).",
    "keywords": [
      "AntiAliasing outdated",
      "GD drivers",
      "aliased output",
      "AGG renderer",
      "Cairo renderer",
      "OUTPUTFORMAT driver",
      "jagged edges",
      "MapServer 6.0 change"
    ]
  },
  {
    "id": 259,
    "text": "For GD-based antialiasing, the documented recipe is: set MAP IMAGETYPE to PNG24 (24‑bit PNG) or JPEG, set each relevant LAYER TRANSPARENCY to ALPHA, and set STYLE ANTIALIAS to TRUE inside the CLASS/STYLE. The template shows these changes are mapfile-level (IMAGETYPE) plus layer/style-level (TRANSPARENCY/ANTIALIAS). If nothing changes, confirm you are truly using a GD OUTPUTFORMAT and that your mapserver build supports the chosen IMAGETYPE; also remember that AGG ignores ANTIALIAS keywords because it is antialiased globally.",
    "keywords": [
      "IMAGETYPE PNG24",
      "TRANSPARENCY ALPHA",
      "STYLE ANTIALIAS TRUE",
      "GD renderer",
      "CLASS STYLE",
      "output driver check",
      "build support",
      "antialias troubleshooting"
    ]
  },
  {
    "id": 260,
    "text": "The GD antialias notes warn against using SYMBOL or SIZE at the CLASS level for lines and polygon outlines; use STYLE WIDTH instead, and avoid WIDTH unless you need thicker strokes. If you must use a custom SYMBOL, choose SYMBOL TYPE ELLIPSE because it supports antialiasing. A key migration gotcha: SYMBOL TYPE CARTOLINE was removed in MapServer 6, so older dashed-line examples no longer work; for dashed patterns you typically need AGG rendering with STYLE PATTERN. When a dashed line suddenly disappears, check for CARTOLINE usage first.",
    "keywords": [
      "GD limitations",
      "STYLE WIDTH",
      "SYMBOL TYPE ELLIPSE",
      "CLASS SIZE pitfall",
      "CARTOLINE removed",
      "STYLE PATTERN",
      "dashed line errors",
      "MapServer 6 migration"
    ]
  },
  {
    "id": 261,
    "text": "Dynamic charting (added in MapServer 5.0) draws pie or bar charts from feature attributes. Renderer support is strict: MapServer 7+ supports dynamic charts with AGG (PNG output) and Cairo (PDF/SVG), while the GD renderer was removed in 7.0 (MapServer 5–6 supported GD and AGG). Attempting to render a chart layer with an unsupported renderer can lead to undefined behavior. If charts do not appear or render incorrectly, verify the OUTPUTFORMAT DRIVER (AGG/ or CAIRO/) before debugging the chart layer itself.",
    "keywords": [
      "dynamic charting",
      "TYPE CHART",
      "AGG renderer",
      "Cairo renderer",
      "GD removed in 7.0",
      "unsupported renderer",
      "OUTPUTFORMAT DRIVER",
      "undefined behavior"
    ]
  },
  {
    "id": 262,
    "text": "A chart layer is declared in a mapfile with LAYER TYPE CHART. Chart behavior is controlled mainly through LAYER PROCESSING keys, such as CHART_TYPE (pie/bar variants) and CHART_SIZE (size in pixels). The chart layer uses normal MapServer CLASS blocks for the visual categories; each CLASS typically defines one slice or bar, and colors come from the CLASS STYLE. When troubleshooting, first confirm the layer really is TYPE CHART and that required PROCESSING directives (e.g., CHART_TYPE and CHART_SIZE) are present.",
    "keywords": [
      "LAYER TYPE CHART",
      "PROCESSING directives",
      "CHART_TYPE",
      "CHART_SIZE",
      "CLASS blocks",
      "chart colors",
      "mapfile syntax",
      "missing chart output"
    ]
  },
  {
    "id": 263,
    "text": "CHART_SIZE_RANGE lets chart diameters vary per feature using an attribute. The PROCESSING syntax is \"CHART_SIZE_RANGE=itemname minsize maxsize minval maxval exponent\" (or just \"CHART_SIZE_RANGE=itemname\"). Values below minval clamp to minsize, and values above maxval clamp to maxsize. An optional exponent applies a non-linear scaling to the diameter, which is useful when a few extreme values dominate. If charts look almost the same size everywhere, check whether your minval/maxval are realistic for the data and whether exponent is too large or too small.",
    "keywords": [
      "CHART_SIZE_RANGE",
      "attribute-driven size",
      "minval maxval",
      "minsize maxsize",
      "exponent scaling",
      "clamping",
      "chart scaling bugs",
      "data range"
    ]
  },
  {
    "id": 264,
    "text": "In dynamic chart layers, each plotted value (a pie slice or a bar) is defined by a CLASS. The numeric value is read from the SIZE keyword of the first STYLE block in that CLASS—an unusual but intentional design to avoid new mapfile keywords. SIZE can be a constant or an attribute substitution, depending on your templating/expression setup. If all slices are equal or values appear as zero, check that the first STYLE in each CLASS contains SIZE and that the SIZE expression resolves to a numeric value for every feature.",
    "keywords": [
      "chart values",
      "CLASS per slice",
      "first STYLE SIZE",
      "attribute substitution",
      "SIZE numeric",
      "zero values",
      "mapfile debugging",
      "STYLE order"
    ]
  },
  {
    "id": 265,
    "text": "Pie charts are enabled with PROCESSING \"CHART_TYPE=pie\" on the chart layer. The pie size comes from PROCESSING \"CHART_SIZE=<pixels>\" (not from the STYLE block). Each CLASS represents a slice, where the relative slice percentage is based on the CLASS’s STYLE SIZE value compared to the sum of all slice values for that feature. Colors are taken from STYLE COLOR. If the pie renders but looks wrong, verify the data values driving SIZE and remember CHART_SIZE controls the overall symbol size.",
    "keywords": [
      "CHART_TYPE=pie",
      "CHART_SIZE",
      "pie slices",
      "STYLE SIZE values",
      "relative percentages",
      "STYLE COLOR",
      "pie chart troubleshooting",
      "chart layer"
    ]
  },
  {
    "id": 266,
    "text": "Pie charts can be driven by expressions so that a feature can contribute to multiple categories. One pattern is to expose a field with PROCESSING \"ITEMS=TYPE\", set CLASSITEM \"TYPE\", and use regex EXPRESSION rules (e.g., matching “corn”, “wheat”, “rice” in a comma-separated attribute). Each matching CLASS can then use STYLE SIZE 1 and a distinct color to build a per-feature pie. If no slices appear for some features, the most common cause is an EXPRESSION that doesn’t match the attribute formatting (commas, spaces, case).",
    "keywords": [
      "Pie chart expressions",
      "PROCESSING ITEMS",
      "CLASSITEM",
      "regex EXPRESSION",
      "multi-valued attribute",
      "category matching",
      "msautotest examples",
      "missing slices"
    ]
  },
  {
    "id": 267,
    "text": "Bar graphs are enabled with PROCESSING \"CHART_TYPE=BAR\" on a chart layer. For each feature, every CLASS contributes a bar, with the bar’s magnitude taken from the CLASS’s first STYLE SIZE value. By default, the vertical axis is auto-scaled per feature to span the minimum and maximum values and include 0 (the origin). If you need all features to share a consistent scale (e.g., for visual comparison), add PROCESSING \"CHART_BAR_MINVAL=<val>\" and/or \"CHART_BAR_MAXVAL=<val>\"; out-of-range values are clipped.",
    "keywords": [
      "CHART_TYPE=BAR",
      "STYLE SIZE values",
      "auto-scaled axis",
      "CHART_BAR_MINVAL",
      "CHART_BAR_MAXVAL",
      "value clipping",
      "consistent scale",
      "bar chart debugging"
    ]
  },
  {
    "id": 268,
    "text": "Stacked bar graphs are a variant of charting where multiple values are accumulated into a single stacked symbol. The documentation notes stacked bar graphs can be drawn using PROCESSING \"CHART_TYPE=VBAR\". As with other chart types, the contributing values still come from CLASS definitions and their first STYLE SIZE values, so missing or non-numeric SIZE values will break the stack. If you expected stacked output but see separate bars, double-check CHART_TYPE and confirm you are not still using CHART_TYPE=BAR in the layer PROCESSING block.",
    "keywords": [
      "stacked bar graphs",
      "CHART_TYPE=VBAR",
      "chart variants",
      "CLASS values",
      "STYLE SIZE",
      "non-numeric SIZE",
      "processing keys",
      "unexpected output"
    ]
  },
  {
    "id": 269,
    "text": "Flash (SWF) output is described for MapServer 4–5 but is marked as no longer supported since MapServer 6.0. To verify whether an old build has SWF support, run mapserv -v and look for OUTPUT=SWF. SWF support depended on the Ming library (a C library for generating SWF movies) and some distributions such as MS4W shipped binaries with SWF enabled. If your build lacks OUTPUT=SWF, SWF OUTPUTFORMAT definitions will be ignored or fail at runtime.",
    "keywords": [
      "SWF deprecated",
      "MapServer 6.0 removal",
      "mapserv -v",
      "OUTPUT=SWF",
      "Ming library",
      "MS4W",
      "build flags",
      "Flash output"
    ]
  },
  {
    "id": 270,
    "text": "SWF output is configured through an OUTPUTFORMAT with DRIVER swf, MIMETYPE \"application/x-shockwave-flash\", and IMAGEMODE PC256. A key FORMATOPTION is OUTPUT_MOVIE, which can be set to SINGLE (one movie containing raster output for all layers) or MULTIPLE (a main SWF plus one SWF per map layer—vector movies for vector layers, raster movies for raster layers). If you expect per-layer SWFs but only get one file, check whether OUTPUT_MOVIE was set to MULTIPLE.",
    "keywords": [
      "OUTPUTFORMAT swf",
      "DRIVER swf",
      "IMAGEMODE PC256",
      "OUTPUT_MOVIE",
      "SINGLE movie",
      "MULTIPLE movies",
      "per-layer SWF",
      "MIMETYPE SWF"
    ]
  },
  {
    "id": 271,
    "text": "Additional SWF FORMATOPTION settings affect performance and client loading. FULL_RESOLUTION applies to vector layers: setting it to FALSE enables filtering that can reduce SWF size (default TRUE). LOAD_AUTOMATICALLY=OFF prevents automatic loading of per-layer SWFs (default ON), which can be useful when the client application wants to control layer loading. When SWF files are unexpectedly huge or slow to start, review FULL_RESOLUTION and whether you are producing MULTIPLE movies with automatic loading enabled.",
    "keywords": [
      "SWF FORMATOPTION",
      "FULL_RESOLUTION",
      "vector filtering",
      "LOAD_AUTOMATICALLY",
      "file size",
      "startup performance",
      "MULTIPLE output",
      "client-controlled loading"
    ]
  },
  {
    "id": 272,
    "text": "To export feature attributes into SWF for interactivity, define layer METADATA including SWFDUMPATTRIBUTES (a comma-separated list of attribute names). RESULT_FIELDS and DESCRIPTION metadata are often used alongside it. When enabled, MapServer writes ActionScript arrays containing attribute names and per-shape values into the SWF output, making the layer effectively “queryable” from the Flash client. If events do not fire or attributes are missing, confirm SWFDUMPATTRIBUTES is present and the field names match the data source exactly.",
    "keywords": [
      "SWFDUMPATTRIBUTES",
      "layer METADATA",
      "RESULT_FIELDS",
      "ActionScript arrays",
      "export attributes",
      "queryable layer",
      "field name mismatch",
      "Flash interactivity"
    ]
  },
  {
    "id": 273,
    "text": "Mouse events in SWF output are available only for layers that export attributes via SWFDUMPATTRIBUTES. When an event occurs (MOUSEUP, MOUSEDOWN, MOUSEOVER, MOUSEOUT), an ActionScript callback like _root.ElementSelected(LayerId, ShapeId, Event) can be triggered, and the client application is expected to implement ElementSelected to react (e.g., display attributes). Highlighting is supported on queryable layers: MapServer uses the QueryMap object’s COLOR for the highlight on MOUSEOVER (older versions highlighted in red).",
    "keywords": [
      "SWF events",
      "MOUSEOVER",
      "ElementSelected callback",
      "LayerId ShapeId",
      "queryable layers",
      "QueryMap COLOR",
      "highlighting",
      "Flash client logic"
    ]
  },
  {
    "id": 274,
    "text": "Flash output had important limitations. Ming uses FDB fonts and does not support TrueType fonts directly, so text rendering requires generating FDB files. Support by layer type was uneven: point, line, annotation, and polygon vector layers were listed as done; circle layers and some low-level circle drawing functions were not done. Raster layers and WMS layers were supported, but surround components like legend and scalebar were not supported. When a SWF map is missing a legend or scalebar, this is a feature gap rather than a mapfile error.",
    "keywords": [
      "Ming fonts",
      "FDB font files",
      "TrueType unsupported",
      "circle layer limitations",
      "raster layer support",
      "WMS layer support",
      "legend unsupported",
      "scalebar unsupported"
    ]
  },
  {
    "id": 275,
    "text": "The HTML legend feature replaces the traditional image legend (GIF/PNG) by inserting generated HTML into your main CGI template. It requires three pieces: (1) a LEGEND object in the mapfile with TEMPLATE set, (2) a [legend] tag placed in the application HTML template, and (3) a separate HTML legend template file that defines how groups, layers, and classes are rendered. This approach is useful when you need checkboxes, links, or richer layout than an image legend can provide.",
    "keywords": [
      "HTML legend",
      "LEGEND TEMPLATE",
      "[legend] tag",
      "CGI templates",
      "legend template file",
      "checkbox legend",
      "rich legend layout",
      "MapServer CGI"
    ]
  },
  {
    "id": 276,
    "text": "Enable HTML legends by setting TEMPLATE \"legend.html\" (must end with .html) inside the mapfile’s LEGEND object. When TEMPLATE is set, MapServer reads that legend template file and injects the resulting HTML at the position of the [legend] tag in the main application template. If TEMPLATE is not set, [legend] behaves traditionally and returns a URL to a generated legend image, usually used inside <IMG SRC=\"[legend]\">. When converting an existing app to HTML legends, remove the IMG tag and leave a plain [legend] placeholder.",
    "keywords": [
      "LEGEND object",
      "TEMPLATE legend.html",
      "traditional legend image",
      "IMG SRC [legend]",
      "HTML injection",
      "template extension .html",
      "conversion steps",
      "legacy behavior"
    ]
  },
  {
    "id": 277,
    "text": "The CGI [legend] tag changes meaning depending on whether the LEGEND TEMPLATE is configured. With HTML legends enabled, [legend] expands to a block of HTML rather than an image URL. If “legend mode” is specified in the request URL, MapServer can return a complete legend image (GIF) when no template is specified, which can confuse debugging if you test via URL directly. If you unexpectedly receive an image instead of HTML, check both the mapfile LEGEND TEMPLATE and the CGI request parameters.",
    "keywords": [
      "CGI [legend]",
      "legend mode",
      "HTML vs image output",
      "URL parameters",
      "debugging legend output",
      "LEGEND TEMPLATE check",
      "MapServer CGI"
    ]
  },
  {
    "id": 278,
    "text": "An HTML legend template file can include up to one of each major block: [leg_group_html]…[/leg_group_html], [leg_layer_html]…[/leg_layer_html], and [leg_class_html]…[/leg_class_html]. Optional header and footer blocks ([leg_header_html], [leg_footer_html]) wrap the generated content. The parser ignores any text outside the [leg_*_html] block pairs, so place all desired markup inside these blocks. A common pitfall is adding HTML outside the supported blocks and wondering why it never appears.",
    "keywords": [
      "legend template blocks",
      "leg_group_html",
      "leg_layer_html",
      "leg_class_html",
      "leg_header_html",
      "leg_footer_html",
      "parser ignores outside text",
      "template pitfalls"
    ]
  },
  {
    "id": 279,
    "text": "The [leg_group_html] block groups legend output by LAYER GROUP. If this block is used, layers without a GROUP are omitted entirely, along with their classes. Group visibility can be controlled with opt_flag (bitmask): 1 show groups even if out of scale, 2 show even if all layers are STATUS OFF, 4 show QUERY layers, 8 show ANNOTATION layers (deprecated). Group order is decided by an order_metadata field (explained in the layer ordering rules). If a whole group disappears, first check GROUP assignments and the opt_flag settings.",
    "keywords": [
      "leg_group_html",
      "LAYER GROUP",
      "opt_flag bitmask",
      "out of scale groups",
      "STATUS OFF groups",
      "QUERY layers",
      "group ordering",
      "missing group troubleshooting"
    ]
  },
  {
    "id": 280,
    "text": "The [leg_layer_html] block controls per-layer headers in the legend. With order_metadata=<field>, layers are sorted by the numeric value of that layer metadata field; values < 0 hide the layer, and ties fall back to the mapfile layer order. The opt_flag bitmask controls whether to show out-of-scale layers (1), STATUS OFF layers (2), QUERY layers (4), or ANNOTATION layers (8, deprecated). Useful tags include [leg_layer_name], [leg_layer_group], [leg_layer_index], and [leg_layer_minscale]/[leg_layer_maxscale] for conditional display or ordering.",
    "keywords": [
      "leg_layer_html",
      "order_metadata",
      "legend_order metadata",
      "opt_flag",
      "hide layer <0",
      "leg_layer_name",
      "leg_layer_group",
      "minscale maxscale"
    ]
  },
  {
    "id": 281,
    "text": "The [leg_class_html] block defines how classes are listed. Classes with NULL/empty NAME are not displayed, which often explains “missing” legend entries. The opt_flag parameter behaves like the layer opt_flag (show out of scale, STATUS OFF, QUERY, ANNOTATION). Class-level tags include [leg_class_index], [leg_class_name], [leg_class_title], and class min/max scale. The [leg_icon width=<w> height=<h>] tag returns a URL to a legend icon (first class in context, or the current class in class context), and [metadata name=...] can pull values from layer/web metadata.",
    "keywords": [
      "leg_class_html",
      "empty CLASS NAME hidden",
      "leg_class_index",
      "leg_class_title",
      "leg_icon URL",
      "class scale limits",
      "metadata tag",
      "missing legend items"
    ]
  },
  {
    "id": 282,
    "text": "HTML legend templates can use [if]…[/if] logic to maintain UI state, such as marking a layer checkbox CHECKED when the layer is in DEFAULT status. The set of testable values depends on context. In a group block you can test layer_status (0 OFF, 1 ON, 2 DEFAULT), layer_visible, group_name, layer_queryable (added in 5.6), and metadata values. In a layer block you can test layer_status and visibility similarly. Precedence rules matter: special keywords are evaluated before layer metadata, then web/map metadata. If an [if] never triggers, check context and name.",
    "keywords": [
      "template [if] tag",
      "layer_status values",
      "layer_visible",
      "layer_queryable",
      "group_name",
      "checkbox CHECKED",
      "metadata precedence",
      "conditional legend logic"
    ]
  },
  {
    "id": 283,
    "text": "Inverse Distance Weighted (IDW) interpolation (added in MapServer 8.0) rasterizes vector features by weighting samples as an inverse power of distance from each output pixel. Configure an IDW raster layer with CONNECTIONTYPE IDW and set CONNECTION to a source layer NAME or GROUP (NAME takes precedence). The source is typically a TYPE POINT layer; other geometries contribute samples at vertices. IDW_RADIUS controls the search radius in pixels, trading performance for smoothness. If results show edge artifacts, review IDW_COMPUTE_BORDERS and your tiling strategy.",
    "keywords": [
      "IDW interpolation",
      "CONNECTIONTYPE IDW",
      "CONNECTION layername",
      "TYPE POINT source",
      "IDW_RADIUS",
      "IDW_COMPUTE_BORDERS",
      "tiling artifacts",
      "MapServer 8.0"
    ]
  },
  {
    "id": 284,
    "text": "IDW_COMPUTE_BORDERS addresses the fact that a kernel of radius r cannot be computed for r pixels along image edges. By default MapServer extends the input datasource search rectangle by r pixels outside the map extent so the computed raster covers the full output. For tiled rendering, this extra work may be unnecessary if the tile service already requests a metatile buffer; you can set IDW_COMPUTE_BORDERS=OFF to avoid the overhead. IDW_WEIGHT adjusts the power used in the inverse-distance weighting (default 1.0). If the surface is too smooth or too spiky, tune IDW_RADIUS and IDW_WEIGHT together.",
    "keywords": [
      "IDW_COMPUTE_BORDERS",
      "edge pixels",
      "metatile buffer",
      "performance tuning",
      "IDW_WEIGHT",
      "inverse-distance power",
      "smoothness control",
      "tile optimization"
    ]
  },
  {
    "id": 285,
    "text": "An IDW layer outputs a raster band that is typically styled using a color ramp. The example mapfile uses OFFSITE 0 0 0 and a single CLASS with multiple STYLE blocks, each applying COLORRANGE and DATARANGE to map intensity ranges (e.g., 0–32 then 32–255) to RGBA hex colors. This pattern is shared with Kernel Density Estimation heatmaps. If your ramp looks “flat,” check that the produced values really span 0–255 (or that your normalization/scaling is appropriate) before adjusting the DATARANGE cut points.",
    "keywords": [
      "IDW color ramp",
      "OFFSITE",
      "CLASS multiple STYLE",
      "COLORRANGE",
      "DATARANGE",
      "0-255 intensity",
      "RGBA hex colors",
      "flat ramp troubleshooting"
    ]
  },
  {
    "id": 286,
    "text": "HTML imagemaps can be generated via the shpxy approach, which uses MapServer’s query engine to return an HTML <map> with <area> elements. You issue a query request, MapServer runs a query (often mode=nquery), and it expands query templates to produce HTML returned to the browser. Typical components are: a mapfile, a query body template (processed once per result), and optional query header/footer templates (processed once). If you see an empty imagemap, verify the query actually returns results and that TEMPLATE/HEADER/FOOTER paths are correct.",
    "keywords": [
      "HTML imagemaps",
      "shpxy",
      "MapServer query",
      "mode=nquery",
      "query templates",
      "header footer templates",
      "<map> <area>",
      "empty results"
    ]
  },
  {
    "id": 287,
    "text": "To build an imagemap, your mapfile layer must reference templates: set LAYER TEMPLATE to the body template, and optionally set HEADER and FOOTER to wrap the output with opening/closing <map> tags. A typical setup includes QUERYMAP STATUS ON and a point layer with STATUS DEFAULT. The body template can substitute attribute values (e.g., [NAME]) into href/title/alt fields. If you generate the map image and the imagemap from separate mapfiles, make sure SIZE and EXTENT are identical; otherwise the computed image coordinates will not align with the displayed map.",
    "keywords": [
      "LAYER TEMPLATE",
      "HEADER FOOTER",
      "QUERYMAP",
      "STATUS DEFAULT",
      "attribute substitution",
      "SIZE/EXTENT alignment",
      "separate mapfiles",
      "misaligned hotspots"
    ]
  },
  {
    "id": 288,
    "text": "In a point-layer imagemap template, shpxy generates image-space coordinates for each query result. A common pattern is an <area shape=\"circle\"> with coords=\"[shpxy precision=0 proj=image xf=\",\" yf=\",7\"]\" where precision=0 forces integer coordinates. The xf/yf formatting options insert separators and can append a fixed radius (here 7 pixels) for the circle hotspot. If your coords string is malformed, the usual cause is incorrect xf/yf formatting or missing commas; inspect the rendered HTML and adjust xf/yf accordingly.",
    "keywords": [
      "shpxy tag",
      "proj=image",
      "precision=0",
      "xf/yf formatting",
      "circle hotspot radius",
      "coords formatting",
      "template debugging",
      "point imagemap"
    ]
  },
  {
    "id": 289,
    "text": "For polygon imagemaps, the body template typically uses <area shape=\"poly\" coords=\"[shpxy precision=0 proj=image]\" ...> to emit the full vertex coordinate list. The imagemap is requested via a MapServer CGI URL that specifies the mapfile, query layer, and query mode—for example map=/path/mapfile.map, qlayer=sites, mode=nquery, searchmap=true (GET or POST). If the polygons don’t match the rendered map, confirm the query is run against the same extent/size as the image and that the layer being queried is the layer used to draw the features.",
    "keywords": [
      "polygon imagemap",
      "<area shape=poly>",
      "shpxy coords list",
      "mapserv CGI request",
      "qlayer",
      "mode=nquery",
      "searchmap=true",
      "alignment troubleshooting"
    ]
  },
  {
    "id": 290,
    "text": "Kernel Density Estimation (KDE) heatmaps (added in MapServer 7.0) convert sparse point observations into a raster where each pixel is influenced by nearby samples, typically decreasing with distance. The resulting raster is usually styled with a color ramp so hue indicates density, and optionally the intensity can reflect an attribute-based weight. MapServer uses the term “heatmap” here specifically for KDE output. If your output looks like isolated dots rather than a continuous surface, the most common cause is a kernel radius that is too small for the map scale.",
    "keywords": [
      "kernel density",
      "dynamic heatmap",
      "KDE raster",
      "sparse points",
      "density surface",
      "color ramp",
      "MapServer 7.0",
      "radius too small"
    ]
  },
  {
    "id": 291,
    "text": "To configure a KDE layer, set LAYER CONNECTIONTYPE to KERNELDENSITY and set CONNECTION to a source layer NAME or GROUP (usually a TYPE POINT layer). KERNELDENSITY_RADIUS sets the gaussian filter radius in pixels; larger radii are smoother but cost more CPU. KERNELDENSITY_COMPUTE_BORDERS extends the datasource search rectangle by r pixels so the heatmap covers the full output extent; for tiles with metatile buffering you can disable it to reduce overhead. If a heatmap has clipped edges, COMPUTE_BORDERS is the first setting to check.",
    "keywords": [
      "CONNECTIONTYPE KERNELDENSITY",
      "KERNELDENSITY_RADIUS",
      "gaussian filter",
      "KERNELDENSITY_COMPUTE_BORDERS",
      "source points layer",
      "tiling performance",
      "clipped edges",
      "search rectangle"
    ]
  },
  {
    "id": 292,
    "text": "KERNELDENSITY_NORMALIZATION controls how sample accumulation is scaled into the 0–255 intensity band used by COLORRANGE ramps. NORMALIZATION=AUTO rescales each request so values span 0–255, which maximizes contrast but makes the same location vary between requests (problematic for tiles). Using a numeric normalization multiplies samples by a fixed factor; you typically find the factor by trial and error so that most outputs use the full range without saturating. Values outside 0–255 are clipped, so overscaling produces large saturated (255) regions.",
    "keywords": [
      "KERNELDENSITY_NORMALIZATION",
      "AUTO scaling",
      "fixed numeric scaling",
      "0-255 intensity",
      "tiling consistency",
      "trial and error factor",
      "clipping",
      "saturation artifacts"
    ]
  },
  {
    "id": 293,
    "text": "Heatmaps are commonly styled with multiple STYLE blocks using COLORRANGE and DATARANGE, mapping intensity subranges to RGBA colors. By default, color interpolation between stops is done in RGB, which can look washed out. Set PROCESSING \"RANGE_COLORSPACE=HSL\" to interpolate in HSL space for more visually intuitive ramps. If your ramp transitions look gray or muddy, switch to HSL colorspace before changing your stop colors, and confirm your DATARANGE breakpoints match the actual distribution of intensity values.",
    "keywords": [
      "COLORRANGE",
      "DATARANGE",
      "RANGE_COLORSPACE",
      "HSL interpolation",
      "RGB washed out",
      "heatmap styling",
      "ramp breakpoints",
      "visual ramp issues"
    ]
  },
  {
    "id": 294,
    "text": "An example KDE mapfile defines a raster layer (NAME heatmap) with CONNECTIONTYPE kerneldensity, CONNECTION \"points\", and PROCESSING keys for RANGE_COLORSPACE, KERNELDENSITY_RADIUS, COMPUTE_BORDERS, and NORMALIZATION. The layer sets OFFSITE 0 0 0 and uses two STYLE ramps (0–32 and 32–255) to fade from transparent blue to opaque blue, then to red. The source points layer is a normal TYPE POINT layer. For OGC services the example also sets WEB METADATA like ows_srs and ows_enable_request.",
    "keywords": [
      "heatmap example mapfile",
      "OFFSITE",
      "two-step ramp",
      "transparent to opaque",
      "points source layer",
      "ows_srs metadata",
      "ows_enable_request",
      "PROCESSING keys"
    ]
  },
  {
    "id": 295,
    "text": "The kernel radius can be made scale-dependent using SCALETOKEN. One pattern is PROCESSING \"KERNELDENSITY_RADIUS=%radius%\" plus a SCALETOKEN block that maps scale denominators to token values (e.g., radius 50 for scales up to 1:25,000,000 and radius 10 beyond that). The documentation notes that other PROCESSING keys can be updated with the same technique. If a heatmap looks overly blurred when zoomed out or too sharp when zoomed in, SCALETOKEN-based radius control is an effective fix.",
    "keywords": [
      "SCALETOKEN",
      "scale-dependent radius",
      "KERNELDENSITY_RADIUS token",
      "VALUES scale mapping",
      "zoom-dependent blur",
      "dynamic processing",
      "tile zoom levels",
      "heatmap tuning"
    ]
  },
  {
    "id": 296,
    "text": "Sample weights for KDE (and similarly IDW) can be controlled from the source vector layer using CLASS/STYLE/SIZE. For numeric weighting, set STYLE SIZE [attribute] so each feature contributes proportionally to an attribute value. For non-numeric categories, use CLASSITEM (e.g., risk) and multiple CLASS blocks with EXPRESSION rules (“high”, “medium”, “low”), assigning different STYLE SIZE values (5/3/1). If weighting appears ignored, confirm the heatmap layer’s CONNECTION points to the weighted source layer and that the STYLE SIZE values resolve correctly for every feature.",
    "keywords": [
      "heatmap weighting",
      "STYLE SIZE attribute",
      "CLASSITEM categories",
      "EXPRESSION rules",
      "risk levels",
      "numeric vs non-numeric weights",
      "source layer connection",
      "ignored weights"
    ]
  },
  {
    "id": 297,
    "text": "This PDF slice ends with the heading for “9.1.9 OGR Output” (author Frank Warmerdam, last updated 2022‑04‑25) but does not include the body text. In the full MapServer manual, OGR output typically covers exporting vector results through GDAL/OGR drivers rather than producing an image, and it is configured through OUTPUTFORMAT/driver settings and related metadata. If you need the exact mapfile syntax and supported format options, you’ll need the next pages of the documentation beyond this excerpt.",
    "keywords": [
      "OGR Output",
      "Frank Warmerdam",
      "vector export",
      "GDAL/OGR drivers",
      "OUTPUTFORMAT",
      "missing section body",
      "documentation continuation",
      "data download output"
    ]
  },
  {
    "id": 298,
    "text": "OGR output support (added in MapServer 6.0) lets MapServer return vector feature data from queries, mainly for WMS GetFeatureInfo and WFS GetFeature responses. It relies on GDAL/OGR; a quick sanity check is running “mapserv -v” and confirming INPUT=OGR is listed. OGR output is configured through OUTPUTFORMAT blocks that select an OGR driver (like CSV, GML, GeoJSON, FlatGeoBuf, Shapefile) and control how results are built and packaged. Unlike image outputs, OGR output implicitly uses IMAGEMODE FEATURE and focuses on attributes and geometries rather than pixels.",
    "keywords": [
      "OGR output",
      "WMS GetFeatureInfo",
      "WFS GetFeature",
      "GDAL/OGR",
      "mapserv -v",
      "INPUT=OGR",
      "IMAGEMODE FEATURE",
      "vector query output"
    ]
  },
  {
    "id": 299,
    "text": "An OGR OUTPUTFORMAT uses DRIVER \"OGR/<format>\" where <format> matches an ogr2ogr -f driver name. You can pass dataset creation options with FORMATOPTION \"DSCO:<key>=<value>\" and layer creation options with \"LCO:<key>=<value>\" (for example, CSV GEOMETRY=AS_WKT). Use FORMATOPTION \"FILENAME=...\" to name the returned datasource (and, for zip results, you can use basename.ext.zip so the inner datasource has a meaningful name). MapServer 7.0.2+ can also include feature ids via FORMATOPTION \"USE_FEATUREID=true\" when layer metadata ows_featureid is set—use cautiously because some drivers react poorly to arbitrary FIDs.",
    "keywords": [
      "OUTPUTFORMAT",
      "DRIVER OGR",
      "ogr2ogr -f",
      "DSCO",
      "LCO",
      "FILENAME",
      "USE_FEATUREID",
      "ows_featureid",
      "GeoJSON id"
    ]
  },
  {
    "id": 300,
    "text": "OGR output controls where intermediate files are written with FORMATOPTION \"STORAGE=memory|filesystem|stream\". “filesystem” (the default) writes into WEB TEMPPATH or the MS_TEMPPATH environment, then streams results back. “memory” tries to build results in virtual memory (often via /vsimem). “stream” attempts direct stdout output by creating the datasource as “/vsistdout”, but only a few OGR drivers work reliably this way (commonly CSV, sometimes KML/GML). If you see missing/empty outputs, mismatched driver capabilities and STORAGE mode are common culprits.",
    "keywords": [
      "STORAGE",
      "filesystem",
      "memory",
      "stream",
      "MS_TEMPPATH",
      "TEMPPATH",
      "/vsimem",
      "/vsistdout",
      "OGR drivers"
    ]
  },
  {
    "id": 301,
    "text": "Several LAYER METADATA keys influence OGR output, especially for WFS. “wfs_getfeature_formatlist” lists allowed OUTPUTFORMAT NAME values for WFS GetFeature. “wfs_additional_files_in_output” lets you ship extra files or whole directories (paths resolved relative to the mapfile and SHAPEPATH; URLs are allowed if OGR has curl support). Attribute schema can be defined with gml_[item]_type (Integer, Long, Real, Character, Date, Time, DateTime, Boolean), plus gml_[item]_width and gml_[item]_precision. Setting \"gml_types\" \"auto\" can populate type/width/precision from the source (OGR, Shapefile, PostGIS, Oracle Spatial) to avoid everything becoming variable-length strings.",
    "keywords": [
      "wfs_getfeature_formatlist",
      "wfs_additional_files_in_output",
      "LAYER METADATA",
      "gml_types auto",
      "gml_*_type",
      "Long 64-bit",
      "DateTime",
      "field width",
      "precision"
    ]
  },
  {
    "id": 302,
    "text": "MapServer’s POINT/LINE/POLYGON layer model doesn’t map perfectly to OGR’s Simple Features, so geometry type should often be explicit. Set layer metadata “ows_geomtype” (aka wfs_geomtype) to Point, LineString, Polygon, MultiPoint, MultiLineString, MultiPolygon, GeometryCollection, Geometry, or None. If unset, MapServer picks Point/LineString/Polygon based on LAYER TYPE, which can break mixed geometry layers (e.g., polygon + multipolygon), where “Geometry” is safer. For Z-enabled output, append “25D” (e.g., Polygon25D). Empty/null geometries are supported from MapServer 8.0, including in GeoJSON outputs.",
    "keywords": [
      "ows_geomtype",
      "wfs_geomtype",
      "MultiPolygon",
      "Geometry",
      "None geometry",
      "25D",
      "mixed geometries",
      "empty geometries",
      "GeoJSON"
    ]
  },
  {
    "id": 303,
    "text": "PDF output was added in MapServer 3.7, replacing older workflows like shp2pdf by allowing PDF to be declared directly in the mapfile with IMAGETYPE or OUTPUTFORMAT. Raster layers are supported, but the legacy documentation is based on PDFlib; it notes that since MapServer 6.0 PDF output is also available through Cairo (not fully reflected here). PDF is useful for print-oriented maps, but you need to understand which layer types and surround elements the chosen backend can handle before troubleshooting missing content in the resulting PDF.",
    "keywords": [
      "PDF output",
      "IMAGETYPE",
      "OUTPUTFORMAT",
      "MapServer 3.7",
      "PDFlib",
      "Cairo",
      "shp2pdf",
      "print maps"
    ]
  },
  {
    "id": 304,
    "text": "Support limitations matter for debugging PDF maps. Vector layers: points, lines, and polygons are supported; circle layers are not. Dashed lines require PDFlib 6+; polygons filled with symbols are not supported. Raster layers are supported but are converted to JPEG before writing into the PDF. WMS layers are listed as not supported in this doc, and legend/scalebar surround components are also not supported. Fonts: only standard PostScript fonts are supported unless you configure PDFlib UPR font files. If labels trigger errors, testing without the LABEL block helps isolate font configuration issues.",
    "keywords": [
      "PDF limitations",
      "vector layers",
      "circle not supported",
      "dashed lines",
      "raster to JPEG",
      "legend scalebar",
      "PostScript fonts",
      "UPR fonts",
      "LABEL errors"
    ]
  },
  {
    "id": 305,
    "text": "To build MapServer with PDFlib-based PDF support, you compile PDFlib and then enable USE_PDF when building MapServer (on Windows via makefile.vc edits; on Unix via configure with --with-pdf). In the mapfile, define OUTPUTFORMAT NAME pdf, MIMETYPE \"application/x-pdf\", DRIVER pdf, and optionally FORMATOPTION \"OUTPUT_TYPE=RASTER\". OUTPUT_TYPE=RASTER forces all layers to be rendered as rasters and is recommended when WMS layers are involved to avoid transparency problems. A quick functional test is using map2img: map2img -m mapfile.map -o test.pdf.",
    "keywords": [
      "USE_PDF",
      "PDFlib build",
      "--with-pdf",
      "OUTPUTFORMAT pdf",
      "OUTPUT_TYPE=RASTER",
      "transparency",
      "map2img",
      "DRIVER pdf"
    ]
  },
  {
    "id": 306,
    "text": "Common PDFlib PDF errors are font-related. “PDFlib I/O error: Resource configuration file 'pdflib.upr' not found” usually appears when labels require fonts beyond the built-in PostScript set; removing LABEL objects can confirm the diagnosis. For application-generated PDFs, one approach is to render MapServer output as high-DPI PNGs (e.g., 1200x1200 for ~150 dpi on an A4 map region), then insert them into a PDF using a PDF library. With PHP/MapScript you can set extent and layer status, call $map->draw(), saveWebImage(), and finally buffer the PDF and send it with Content-type: application/pdf headers.",
    "keywords": [
      "pdflib.upr",
      "font configuration",
      "LABEL",
      "PHP/MapScript",
      "render PNG then PDF",
      "high DPI",
      "saveWebImage",
      "HTTP headers"
    ]
  },
  {
    "id": 307,
    "text": "SVG output produces an XML-based, scalable vector map (SVG v1.1). MapServer has supported SVG since 4.5, converting MapServer layers into SVG primitives (vector, text, and embedded rasters). The guide references the W3C SVG 1.1 specification and assumes you already know how to build mapfiles and applications. As with PDF, note that from MapServer 6.0 SVG can also be generated through Cairo, which may affect behavior compared to older GD-centric details when you troubleshoot rendering differences.",
    "keywords": [
      "SVG output",
      "SVG 1.1",
      "XML vector graphics",
      "MapServer 4.5",
      "W3C SVG",
      "Cairo backend",
      "scalable maps",
      "OUTPUTFORMAT svg"
    ]
  },
  {
    "id": 308,
    "text": "SVG support varies by feature type. Circle layers are not supported. Lines become SVG polyline elements; STYLE WIDTH is used for SYMBOL 0 thickness, while STYLE SIZE affects other symbols, and dashed symbols become stroke-dasharray patterns. Point layers support VECTOR, ELLIPSE, and TRUETYPE symbols (PIXMAP symbols are not supported). Polygons become SVG polygon elements using STYLE COLOR as fill and OUTLINECOLOR as stroke; SVG patterns are not supported. Raster layers are rendered via GD into temporary PNG/JPEG images and require WEB IMAGEPATH and IMAGEURL. Text becomes SVG <text>; only truetype fonts are supported, and ENCODING outputs UTF‑8 hex values.",
    "keywords": [
      "circle layers",
      "polyline",
      "stroke-dasharray",
      "truetype symbols",
      "pixmap unsupported",
      "OUTLINECOLOR",
      "IMAGEPATH",
      "IMAGEURL",
      "SVG text"
    ]
  },
  {
    "id": 309,
    "text": "To enable SVG, set IMAGETYPE svg and add an OUTPUTFORMAT with NAME svg, MIMETYPE \"image/svg+xml\", and DRIVER svg. Two important FORMATOPTIONs are \"COMPRESSED_OUTPUT=TRUE\" (produces svgz; requires MapServer built with USE_ZLIB) and \"FULL_RESOLUTION=TRUE\" (disables duplicate-point/collinear-line elimination). Testing is straightforward with CGI: mapserv?map=...&mode=map&layers=... and with PHP/MapScript by drawing the map and saveImage() while sending Content-type: image/svg+xml. If output files don’t appear, WEB IMAGEPATH/IMAGEURL paths are the first things to verify.",
    "keywords": [
      "IMAGETYPE svg",
      "OUTPUTFORMAT",
      "COMPRESSED_OUTPUT",
      "svgz",
      "USE_ZLIB",
      "FULL_RESOLUTION",
      "CGI testing",
      "PHP/MapScript",
      "saveImage"
    ]
  },
  {
    "id": 310,
    "text": "goSVG is an SVG variant that embeds extra metadata and a “Map Request Protocol”, while still remaining readable by normal SVG viewers (they simply ignore goSVG headers). To generate goSVG, you need WEB IMAGEPATH/IMAGEURL and a MAP-level PROJECTION using an EPSG code. Define OUTPUTFORMAT with DRIVER svg and FORMATOPTION \"GOSVG=TRUE\", plus thresholds like GOSVG_ZoomInTH, GOSVG_ZoomOutTH, and GOSVG_ScrollTH controlling when zooming/scrolling triggers requests. When troubleshooting, confirm the EPSG projection exists and that goSVG-specific FORMATOPTION names are spelled exactly, as they are driver-specific.",
    "keywords": [
      "goSVG",
      "GOSVG=TRUE",
      "Map Request Protocol",
      "EPSG projection",
      "GOSVG_ZoomInTH",
      "GOSVG_ZoomOutTH",
      "GOSVG_ScrollTH",
      "SVG metadata"
    ]
  },
  {
    "id": 311,
    "text": "MapServer’s tile mode (mode=tile) generates web-mercator tiles on demand. Because it relies on reprojection, each LAYER must have a valid PROJECTION block and MapServer must be compiled with PROJ support. For mode=tile, the output projection is always hard-coded to EPSG:3857 (Google/Web Mercator) and its global extents; the MAP-level PROJECTION is not required unless you also serve OGC services like WMS. Two WEB METADATA knobs help tile quality: tile_map_edge_buffer renders into a buffered frame then clips to reduce symbol/line edge effects, and tile_metatile_level renders a metatile to reduce label repetition (at a performance/memory cost).",
    "keywords": [
      "mode=tile",
      "EPSG:3857",
      "Web Mercator",
      "PROJ support",
      "layer PROJECTION",
      "tile_map_edge_buffer",
      "tile_metatile_level",
      "metatile",
      "edge effects"
    ]
  },
  {
    "id": 312,
    "text": "Tile mode adds CGI parameters: mode=tile, tilemode=gmap (default) with tile=x+y+z, and tilemode=ve for Bing/Virtual Earth with tile as a quadkey string (e.g., 10231). MapServer 8.0 added TILESIZE=width+height to override the default 256x256 tile size, commonly for high-DPI tiles. A typical request includes MAP=path, MODE=tile, TILEMODE, TILE, and LAYERS. If the resulting tiles look “wrong” geographically, remember they will always be in EPSG:3857 even if your mapfile’s normal output projection is EPSG:4326.",
    "keywords": [
      "tilemode=gmap",
      "tilemode=ve",
      "x+y+z",
      "quadkey",
      "TILESIZE",
      "256x256",
      "CGI parameters",
      "LAYERS",
      "MAP parameter"
    ]
  },
  {
    "id": 313,
    "text": "Spherical Mercator (aka Web Mercator / Google Mercator) is the tile projection used by major web mapping clients. Its EPSG code is EPSG:3857. The scheme has one tile at zoom level 0, and at zoom z there are 2^z tiles along each axis; tiles are typically 256x256. Google uses separate x/y/zoom indices, while Bing encodes the tile address as a single quadkey string where each digit (0–3) identifies the child quadrant at each zoom step. Understanding these addressing differences helps when debugging incorrect tile indices or flipped y-axes in client code.",
    "keywords": [
      "Spherical Mercator",
      "EPSG:3857",
      "zoom levels",
      "2^z tiles",
      "quadkey",
      "Google x/y/z",
      "Bing tile scheme",
      "tile indexing"
    ]
  },
  {
    "id": 314,
    "text": "Mapbox Vector Tile (MVT) output is supported in MapServer 7.2+ and requires PBF/protobuf support (mapserv -v should show SUPPORTS=PBF). If missing, you must compile MapServer with protobuf (e.g., WITH_PROTOBUFC). Create an OUTPUTFORMAT with DRIVER MVT (and usually MIMETYPE application/x-protobuf), optional FORMATOPTIONs like EDGE_BUFFER, then request tiles with &map.imagetype=mvt (or set IMAGETYPE). The response is a .pbf file that can be inspected with ogrinfo (“using driver ‘MVT’ successful”). If your tile loads but has empty layers, check that your LAYER projections are valid and that layer filtering/scale dependencies don’t exclude features at the requested zoom.",
    "keywords": [
      "MVT",
      "Mapbox Vector Tile",
      "PBF",
      "protobuf",
      "SUPPORTS=PBF",
      "OUTPUTFORMAT MVT",
      "EDGE_BUFFER",
      "map.imagetype",
      "ogrinfo"
    ]
  },
  {
    "id": 315,
    "text": "Client-side usage typically plugs MapServer into existing tile APIs. Google Maps examples build a URL template pointing at mapserv with mode=tile, tilemode=gmap, and tile={X}+{Y}+{Z}, then use it as an overlay (GTileLayerOverlay) or as an alternate base map (GMapType/addMapType). Bing/Virtual Earth examples use tilemode=ve and tile=%4 inside a VETileSourceSpecification. When troubleshooting blank tiles, verify the generated URL matches what the API expects (token syntax, separators, and required query params like MAP and LAYERS), and confirm your server returns an image for a single hard-coded tile request before integrating it into the JavaScript client.",
    "keywords": [
      "Google Maps tiles",
      "{X}{Y}{Z}",
      "GTileLayerOverlay",
      "alternate base map",
      "Bing Maps",
      "VETileSourceSpecification",
      "tile=%4",
      "URL template",
      "blank tiles debug"
    ]
  },
  {
    "id": 316,
    "text": "Template-driven OUTPUTFORMATs (RFC 36) let MapServer generate custom, text-oriented query outputs—GeoJSON, KML, XML, or other formats—primarily for WMS GetFeatureInfo and WFS GetFeature. The tradeoff is flexibility versus configuration complexity. A key requirement: any layer that will be output must include TEMPLATE \"dummy\" (or similar) so MapServer treats it as query-templated. For WFS, the format must also be listed in \"wfs_getfeature_formatlist\" within WEB or LAYER METADATA (for example, \"gml,geojson\"). If you get “format not supported” errors, missing wfs_getfeature_formatlist is a common cause.",
    "keywords": [
      "template-driven output",
      "RFC 36",
      "GetFeatureInfo",
      "WFS GetFeature",
      "GeoJSON templates",
      "TEMPLATE dummy",
      "wfs_getfeature_formatlist",
      "custom query formats"
    ]
  },
  {
    "id": 317,
    "text": "A template-driven format is declared with OUTPUTFORMAT DRIVER \"TEMPLATE\" and a FORMATOPTION \"FILE=template.ext\" pointing to a template file relative to the mapfile directory. As with normal MapServer templates, the file’s first line must contain the magic string “mapserver template” (typically inside a comment) and that line is not sent to the client. Useful extras include setting MIMETYPE and FORMATOPTION \"ATTACHMENT=...\" to control browser handling and download names. Supported template suffixes include .xml, .html/.htm, .svg, .kml, .gml, .js, and .tmpl—if you use an unsupported extension, MapServer may refuse to load the template.",
    "keywords": [
      "OUTPUTFORMAT TEMPLATE",
      "FILE=...",
      "mapserver template string",
      "relative template path",
      "MIMETYPE",
      "ATTACHMENT",
      "template suffixes",
      "browser download"
    ]
  },
  {
    "id": 318,
    "text": "Template-driven output adds tags that simplify single-file templating. [include src=\"...\"] pulls in another template relative to the mapfile path. [resultset layer=layername]...[/resultset] defines where results for a layer appear, and can use nodata=\"...\" to emit a fallback string when no matches exist. Inside a resultset, [feature]...[/feature] loops over features and supports limit= to cap output and trimlast=\",\" (or similar) to strip a trailing delimiter from the final feature. [join name=join1]...[/join] loops over joined rows from another layer. If your output has dangling commas or missing brackets, misplacing feature/resultset tag boundaries is often the root cause.",
    "keywords": [
      "include tag",
      "resultset tag",
      "feature loop",
      "trimlast",
      "limit",
      "join tag",
      "nodata",
      "single-file templates"
    ]
  },
  {
    "id": 319,
    "text": "The examples show how to emulate the old header/body/footer approach by including external header and footer templates and placing per-layer resultsets between them. A GeoJSON example demonstrates building a FeatureCollection and using [feature trimlast=\",\"] to avoid a trailing comma in the last element. Template-driven formats can be called via query modes (e.g., mode=nquery&qformat=geojson) or exposed through WFS by specifying outputformat=geojson. One practical pitfall: template “reserved words” exist. If an attribute name collides (for example, “id”), you cannot use [id] shorthand and must use [item name=id] instead, or rename the attribute.",
    "keywords": [
      "GeoJSON template",
      "FeatureCollection",
      "mode=nquery",
      "qformat",
      "outputformat",
      "trimlast comma",
      "reserved words",
      "item name=",
      "attribute id"
    ]
  },
  {
    "id": 320,
    "text": "The KML template example highlights advanced geometry tags: [shpxy] helps output multipolygons with holes correctly, and [shplabel] can add a point placemark so features are clickable in Google Earth. Another example generates a reStructuredText “list-table” by outputting fixed-width columns using [item name=\"...\" padding=\"...\"] and transformations like uc=\"true\". These demonstrate that template-driven output is not limited to GIS formats; it can also produce documentation-friendly text, provided you manage spacing, escaping, and looping carefully to keep the output syntactically valid.",
    "keywords": [
      "KML template",
      "shpxy",
      "shplabel",
      "multipolygons with holes",
      "reStructuredText",
      "list-table",
      "padding",
      "uc=true",
      "text outputs"
    ]
  },
  {
    "id": 321,
    "text": "MapServer’s native KML/KMZ output driver (added in 6.0) targets Google Earth by producing KML (kml) or compressed KMZ (kmz). You enable it by setting IMAGETYPE kml/kmz or defining OUTPUTFORMAT blocks with DRIVER \"KML\" or \"KMZ\", plus appropriate MIMETYPE and EXTENSION. Output can be generated via CGI (mode=map) or through WMS GetMap requests. Common OUTPUTFORMAT options include ATTACHMENT=... to name the returned file and maxfeaturestodraw=... to limit output size. If you receive empty KMZ output, check build prerequisites and feature limits first.",
    "keywords": [
      "KML output",
      "KMZ output",
      "IMAGETYPE kml",
      "OUTPUTFORMAT KML",
      "DRIVER KMZ",
      "Google Earth",
      "ATTACHMENT",
      "maxfeaturestodraw",
      "WMS GetMap"
    ]
  },
  {
    "id": 322,
    "text": "Building KML/KMZ support depends on your platform: on Windows there is a KML flag in nmake.opt; on Linux you compile with --with-kml. The KML driver requires the AGG renderer, and KMZ requires GDAL 1.8+ for zipping support. By default, vector feature output is capped at 1000 features per layer. You can control this with (a) layer metadata \"maxfeaturestodraw\", (b) map-level metadata \"maxfeaturestodraw\", or (c) an OUTPUTFORMAT FORMATOPTION \"maxfeaturestodraw=...\". If users report “missing features”, confirm the effective cap and any scale/extent filters.",
    "keywords": [
      "--with-kml",
      "nmake.opt KML",
      "AGG required",
      "GDAL 1.8",
      "KMZ zip",
      "maxfeaturestodraw",
      "feature limit",
      "missing features"
    ]
  },
  {
    "id": 323,
    "text": "KML structure mirrors the mapfile: MapServer produces a top-level <Document> containing all layers. Each LAYER becomes a <Folder>; its name is the layer name (or a fallback like Layer1), and it references a styleUrl stored at the Document level (MapServer collects all layer styles there). Folder presentation can be controlled with kml_folder_display metadata (default “check”, or “radioFolder”, “checkOffOnly”, “checkHideChildren”). Inside each folder, features are emitted as <Placemark> elements with associated geometry. For polygon/line features that also have labels, MapServer can emit a <MultiGeometry> containing the feature geometry plus a point at the label position, making the feature clickable in Google Earth.",
    "keywords": [
      "KML Document",
      "Folder per layer",
      "Placemark",
      "styleUrl",
      "ListStyle",
      "kml_folder_display",
      "MultiGeometry",
      "clickable features"
    ]
  },
  {
    "id": 324,
    "text": "Placemark metadata is driven by KML-specific layer metadata. KML/OWS_DESCRIPTION populates the <description> balloon content, while KML/OWS_INCLUDE_ITEMS uses <ExtendedData> to expose selected attributes. KML_NAME_ITEM can pick which attribute becomes the Placemark <name>. Labelcache is disabled for KML layers. Projections are important: if a layer lacks a PROJECTION block, the driver assumes lat/lon and can emit debug messages; the map-level projection should be EPSG:4326 (the driver will set it automatically if needed). You can also rasterize vector layers via KML_OUTPUTASRASTER=true, trading interactivity for rendering fidelity.",
    "keywords": [
      "OWS_DESCRIPTION",
      "OWS_INCLUDE_ITEMS",
      "ExtendedData",
      "KML_NAME_ITEM",
      "labelcache off",
      "EPSG:4326",
      "projection assumptions",
      "KML_OUTPUTASRASTER",
      "debug messages"
    ]
  },
  {
    "id": 325,
    "text": "KML styling is generated from MapServer styles: point symbols become IconStyle entries that reference dynamically generated symbol images; labels use LabelStyle with color. Lines use LineStyle (color/width), polygons use PolyStyle (fill color) plus optional LineStyle for outlines, and may include LabelStyle. Raster layers are represented as GroundOverlay elements with an href to the generated image and a LatLongBox defining bounds—this requires WEB IMAGEPATH and IMAGEURL to be set. Two common debug-time warnings are that MapServer auto-sets the map projection to EPSG:4326, and that imagepath/imageurl must be configured in the WEB object for the KML driver to write and reference raster assets.",
    "keywords": [
      "IconStyle",
      "LineStyle",
      "PolyStyle",
      "LabelStyle",
      "GroundOverlay",
      "LatLongBox",
      "IMAGEPATH",
      "IMAGEURL",
      "KML styling"
    ]
  },
  {
    "id": 326,
    "text": "UTFGrid is a JSON output format (added in MapServer 7) that exposes feature interaction through an invisible UTF‑8 character grid aligned to the map image. It is typically used by web clients to retrieve feature IDs/properties on mouseover or click without rendering visible labels. Building UTFGrid requires iconv and AGG. Enable it with an OUTPUTFORMAT using DRIVER UTFGRID, MIMETYPE application/json, and options like UTFRESOLUTION (grid pixel size relative to the rendered image, default 4) and DUPLICATES (default true). If your grid is too coarse or too heavy, tuning UTFRESOLUTION and simplifying data can help.",
    "keywords": [
      "UTFGrid",
      "DRIVER UTFGRID",
      "application/json",
      "iconv",
      "AGG",
      "UTFRESOLUTION",
      "DUPLICATES",
      "interactive grids"
    ]
  },
  {
    "id": 327,
    "text": "Feature properties are exposed with two LAYER directives: UTFITEM sets the key used as the grid ID (e.g., UTFITEM \"id\"), and UTFDATA defines a JSON string template such as UTFDATA \"{\"id\":\"[id]\",\"name\":\"[name]\"}\". If UTFITEM is omitted, MapServer uses a sequence number based on rendering order; if UTFDATA is omitted, only the ID is available. Multiple UTFGrid-enabled layers can exist, but only one UTFGrid can be rendered per request—clients that need several grids typically duplicate layers and request different UTFGrid outputs. The UTFGrid driver does not support Truetype symbol rendering, so avoid depending on Truetype symbols for hit detection.",
    "keywords": [
      "UTFITEM",
      "UTFDATA",
      "template substitution",
      "grid ID",
      "rendering order",
      "one UTFGrid per request",
      "OpenLayers",
      "Truetype unsupported"
    ]
  },
  {
    "id": 328,
    "text": "MapServer 8.6 introduces an index page feature (RFC 140) that improves service discoverability. When enabled, visiting the root of a MapServer deployment returns an HTML landing page listing all mapfiles in the system, each linking to a dedicated mapfile homepage with useful service links (WMS capabilities, OGC API landing pages, etc.). The same information is also exposed as JSON endpoints for programmatic monitoring. The feature is driven by the MapServer CONFIG file and uses template rendering similar to MapServer’s OGC API templates, giving administrators a clearer view of what services are publicly exposed.",
    "keywords": [
      "index page",
      "RFC 140",
      "MapServer 8.6",
      "CONFIG file",
      "service discoverability",
      "HTML landing page",
      "JSON endpoints",
      "mapfile listing"
    ]
  },
  {
    "id": 329,
    "text": "Index pages require a CONFIG file that declares a template directory via MS_INDEX_TEMPLATE_DIRECTORY. MapServer ships two template sets: html-index-bootstrap (Bootstrap styled) and html-index-plain (no styling), typically under share/ogcapi/templates. If you only want JSON output, you can set the template directory to an empty string; HTML requests will then return a ConfigError (“Template directory not set.”) while JSON remains accessible via ?f=json. If the template folder is missing or unreadable, MapServer returns an InjaError file access message—often a permissions or path issue.",
    "keywords": [
      "MS_INDEX_TEMPLATE_DIRECTORY",
      "template directory",
      "Bootstrap templates",
      "plain templates",
      "?f=json",
      "ConfigError",
      "InjaError",
      "permissions"
    ]
  },
  {
    "id": 330,
    "text": "If MS_INDEX_TEMPLATE_DIRECTORY is not set at all, MapServer behaves like older versions: browsing the executable without query parameters yields standard CGI errors (“No query information to decode…”) or complains that traditional BROWSE mode needs WEB TEMPLATE. With index pages enabled, the homepage lists all mapfiles defined in the CONFIG MAPS section, showing map name, layer count, and links to each mapfile’s index page (HTML and JSON). Mapfiles that fail to load are shown with “Error loading the map”; in JSON they are marked with \"has-error\": true, which can be used for automated health checks.",
    "keywords": [
      "BROWSE mode",
      "No query information",
      "CONFIG MAPS",
      "layer count",
      "Error loading the map",
      "has-error",
      "health checks",
      "landing.html"
    ]
  },
  {
    "id": 331,
    "text": "Each mapfile listed in the CONFIG MAPS section can be accessed at /<key>/ (keys are case-insensitive) to view a map-specific homepage. The page lists enabled services based on compile-time support and METADATA flags. CGI links to the built-in OpenLayers viewer are usually available unless disabled via ms_enable_modes. OGC API links appear if MapServer was compiled with OGCAPI support and metadata like oga_enable_request or ows_enable_request allows it. WMS/WFS/WCS capability links are shown for supported versions when the corresponding server modules are compiled in and metadata keys (e.g., wms_enable_request=\"*\" or ows_enable_request=\"*\") permit requests. The HTML can be customized with the map.html template.",
    "keywords": [
      "mapfile homepage",
      "OpenLayers viewer",
      "ms_enable_modes",
      "OGC API",
      "oga_enable_request",
      "ows_enable_request",
      "WMS GetCapabilities",
      "WFS GetCapabilities",
      "WCS GetCapabilities"
    ]
  },
  {
    "id": 332,
    "text": "MapServer error output can reflect the last driver or step attempted, not the true root cause. When a layer fails to render, the final message can be misleading, so read the whole chain of messages. This chapter highlights frequent runtime errors tied to raster drawing, mapfile loading, projection definitions, query templates, and image output. A practical workflow is to validate your mapfile with map2img, confirm paths and filesystem permissions, and verify what remote services actually return (image formats, error payloads, and size limits).",
    "keywords": [
      "MapServer errors",
      "debugging workflow",
      "driver fallback",
      "map2img",
      "permissions",
      "projection setup",
      "query templates",
      "raster drawing",
      "image output"
    ]
  },
  {
    "id": 333,
    "text": "The message “drawEPP(): EPPL7 support is not available” is often a red herring. MapServer tries multiple raster drivers when drawing; the EPPL7 driver is attempted last. If a raster draw fails for any reason, you may still see the EPPL7 message at the end. Common underlying causes include a WMS server returning a ServiceException that MapServer does not parse into a clearer error, or the server returning an unexpected image format (for example GIF) that your MapServer build cannot decode. Some WMS servers advertise multiple formats but do not respect them in the GetMap response.",
    "keywords": [
      "drawEPP",
      "EPPL7",
      "msDrawRaster",
      "unsupported image format",
      "WMS ServiceException",
      "GetMap",
      "GIF not supported",
      "raster drivers",
      "misleading error"
    ]
  },
  {
    "id": 334,
    "text": "“loadLayer(): Unknown identifier. Maximum number of classes reached” appears when a layer definition exceeds compiled limits for CLASS/STYLE objects. Older versions used fixed maxima in map.h (e.g., MS_MAXCLASSES 250, MS_MAXSTYLES 5, MS_MAXLAYERS 200). If you hit this, reduce the number of classes (or styles), or rebuild MapServer with higher constants. The documentation notes this limitation was corrected in MapServer 5.0, so upgrading is often a cleaner solution than maintaining a custom build.",
    "keywords": [
      "loadLayer",
      "Unknown identifier",
      "Maximum number of classes",
      "MS_MAXCLASSES",
      "MS_MAXSTYLES",
      "map.h",
      "recompile MapServer",
      "upgrade to 5.0",
      "CLASS limits"
    ]
  },
  {
    "id": 335,
    "text": "“loadMapInternal(): Given map extent is invalid” means MapServer rejected an EXTENT where minx>maxx or miny>maxy. Since MapServer 4.6, MAP and LAYER extents are checked more strictly, including wms_extent metadata. Extents must be written as: EXTENT minx miny maxx maxy and must be in the same units as the MAP-level PROJECTION. To find correct bounds, use GDAL/OGR tools: ogrinfo -summary for vectors (or gdalinfo for rasters) and copy the reported Extent (minx,miny)-(maxx,maxy) into the mapfile.",
    "keywords": [
      "loadMapInternal",
      "Given map extent is invalid",
      "EXTENT order",
      "minx miny maxx maxy",
      "wms_extent",
      "MAP PROJECTION units",
      "ogrinfo",
      "gdalinfo",
      "bounding box"
    ]
  },
  {
    "id": 336,
    "text": "Font-related label errors usually come from incorrect FONTSET configuration. “msGetLabelSize(): Requested font not found” indicates the named font cannot be resolved via the FONTSET lookup file. “msLoadFontset(): Error opening fontset” indicates MapServer cannot open the FONTSET file at all, often due to a bad path. FONTSET paths are relative to the mapfile location unless you provide an absolute path. When troubleshooting, confirm the font alias exists in the FONTSET file and that the map process can read both the FONTSET file and the referenced font files.",
    "keywords": [
      "msGetLabelSize",
      "Requested font not found",
      "msLoadFontset",
      "FONTSET",
      "label rendering",
      "font alias",
      "relative path",
      "file permissions",
      "mapfile location"
    ]
  },
  {
    "id": 337,
    "text": "“msLoadMap(): Failed to open map file” is a path or access problem: MapServer cannot read the .map file at the location it believes it should be. The error output usually echoes the path it tried, which helps spot rewrite, quoting, or configuration mistakes. Verify the path passed to MapServer (CGI MAP= or server config), ensure the web user has filesystem permissions, and then validate syntax with map2img to separate “file not found” from “file found but invalid mapfile syntax”.",
    "keywords": [
      "msLoadMap",
      "Failed to open map file",
      "MAP parameter",
      "filesystem permissions",
      "web user",
      "map2img",
      "path debugging",
      "rewrite issues",
      "mapfile syntax"
    ]
  },
  {
    "id": 338,
    "text": "“msProcessProjection(): no options found in ‘init’ file” indicates the EPSG code or projection is not defined in PROJ’s database (proj.db for PROJ >=6, or the epsg text file for PROJ <6). A related message, “msProcessProjection(): No such file or directory”, indicates MapServer cannot locate the epsg file at all (PROJ <6). On case-sensitive systems, init=epsg:4326 works because it refers to the epsg filename, but init=EPSG:4326 can fail. Verify the definition exists (e.g., via epsg.io or spatialreference.org) and that PROJ resources are discoverable.",
    "keywords": [
      "msProcessProjection",
      "init=epsg",
      "no options found",
      "No such file or directory",
      "PROJ < 6",
      "epsg file",
      "case sensitivity",
      "MS4W",
      "PROJECTION strings"
    ]
  },
  {
    "id": 339,
    "text": "If you see “PROJ error ‘Cannot find proj.db’ when instantiating init=epsg:XXXX”, PROJ (>=6) cannot locate its proj.db SQLite database. Since PROJ 9.1, PROJ_DATA replaces the older PROJ_LIB variable. Fix this by setting PROJ_DATA in MapServer’s global configuration file (mapserver.conf / ms4w.conf) via a CONFIG/ENV block, by using the MAP-level CONFIG \"PROJ_DATA\" \"<path>\" directive in the mapfile, by setting a system environment variable, or by setting it in the web server (e.g., Apache SetEnv).",
    "keywords": [
      "proj.db",
      "Cannot find proj.db",
      "PROJ_DATA",
      "PROJ 9.1",
      "mapserver.conf",
      "ms4w.conf",
      "MAP CONFIG",
      "Apache SetEnv",
      "projection database"
    ]
  },
  {
    "id": 340,
    "text": "“Projection library error. major axis or radius = 0 not given” typically means your PROJECTION block omits an ellipsoid. Since MapServer 4.0 you must include an ellipsoid parameter such as ellps=WGS84 (or equivalent datum/radius parameters) for many projections. Older pre-4.0 mapfiles sometimes relied on defaults and will fail on newer versions. Fix by adding the missing ellps alongside the proj= parameter, or switch to a known EPSG code (init=epsg:XXXX) that expands to a complete definition.",
    "keywords": [
      "major axis or radius = 0",
      "projection library error",
      "ellipsoid required",
      "ellps=WGS84",
      "MapServer 4.0",
      "PROJECTION block",
      "legacy mapfile",
      "EPSG code",
      "datum parameters"
    ]
  },
  {
    "id": 341,
    "text": "“msQueryByPoint(): Search returned no results” can occur even when features exist, if the layer is not configured for queries. For template-based queries, each CLASS used for query output needs a TEMPLATE that points to an HTML fragment using MapServer template syntax. The layer can also define HEADER and FOOTER templates. Within the template, attribute substitutions like [PIN] insert field values, and tokens like [lrn] provide the result line number (starting at 1). Without a TEMPLATE, MapServer may not generate query output even if the spatial hit succeeds.",
    "keywords": [
      "msQueryByPoint",
      "Search returned no results",
      "TEMPLATE required",
      "CLASS TEMPLATE",
      "query output",
      "HEADER FOOTER",
      "MapServer templates",
      "attribute substitution",
      "lrn token"
    ]
  },
  {
    "id": 342,
    "text": "“msReturnPage(): Web application error. Malformed template name” often means MapServer refused a template because its file extension is not allowed. Valid extensions include .gml, .html/.htm, .js, .kml, .svg, .tmpl, .wml, and .xml. The same error can occur when using URL templates with query modes that return multiple results: URL templates are only allowed for mode=query or mode=itemquery. If you use mode=nquery or mode=itemnquery with a URL template, MapServer returns this malformed-template error.",
    "keywords": [
      "msReturnPage",
      "Malformed template name",
      "template extensions",
      "URL template",
      "mode=query",
      "mode=itemquery",
      "mode=nquery",
      "CGI query modes",
      "web application error"
    ]
  },
  {
    "id": 343,
    "text": "“msSaveImageGD(): Unable to access file” is an output-path problem: MapServer cannot write the generated image where it expects. Check IMAGEPATH and IMAGEURL in the mapfile and, in CGI mode, any IMAGEPATH/IMAGEURL variables set by init pages. On Linux/Unix, ensure the web user can write to IMAGEPATH. For WMS services, “Image Size out of range” indicates the client requested WIDTH/HEIGHT beyond the service limits (typically 1–2048). Increase the limit with the MAP-level MAXSIZE parameter, but remember larger images need more CPU and memory.",
    "keywords": [
      "msSaveImageGD",
      "Unable to access file",
      "IMAGEPATH",
      "IMAGEURL",
      "write permissions",
      "CGI init pages",
      "WMS Image Size out of range",
      "WIDTH HEIGHT limit",
      "MAXSIZE"
    ]
  },
  {
    "id": 344,
    "text": "“Unable to load dll (MapScript)” on Windows indicates a dependent shared library cannot be loaded, even if the message names mapscript.dll. Often the missing dependency is required by libmap.dll. Use a dependency inspection tool (e.g., Dependency Walker) or file monitoring to identify which DLL fails. A practical approach is to place all required DLLs in the application directory so the loader can find them. In ASP.NET deployments, remember the app runs under a different account and PATH/permissions may differ between interactive and IIS worker processes.",
    "keywords": [
      "Unable to load dll",
      "MapScript",
      "mapscript.dll",
      "libmap.dll dependencies",
      "Dependency Walker",
      "Windows DLL loading",
      "ASP.NET w3wp.exe",
      "PATH environment",
      "security context"
    ]
  }
]